# :pushpin: Java의 시작2

### :bulb: API, Application Programming Interface
- 프로그램을 개발하기 위해 만들어진 코드들
- API: 응용 프로그램이 운영체제(OS)나 기타 시스템과 통신(상호작용)을 할 때 사용되는 메시지의 형식(함수, 메소드)
    - 자바에서는 클래스와 인터페이스 형태로 제공된다
    - 자바 프로그램을 개발하기 위해 제공되는 클래스들
    - 자바는 JDK에 포함되어 있다
    - Java API Specification Documentation을 참고해야한다 (API 설명서)

### :bulb: Random 클래스
- 의사(꾸며진, 비슷하게 흉내낸) 난수를 생성하는 클래스
- 난수, Random
    - 무작위 수
    - 알 수 없는 값
- 의사 난수, Pseudo Random (pseudo, 수도, 슈도 : 가짜의, 꾸며진)
    - 실제 난수는 아니지만 마치 난수인 것처럼 만들어진 값 -> 컴퓨터에서 난수 대신 사용된다
- 컴퓨터에서 의사 난수를 생성하는 원리
    - 의사 난수의 기초값(seed)을 복잡한 연산을 통해 결과값을 만든다 -> 복잡한 연산을 거꾸로 추적하기 힘들게 만든 것
    - seed가 고정되거나 미리 연산식을 알고 있으면 결과 예측이 가능하다 -> 해결 : seed를 수시로 변경한다
    - 현재시간을 seed로 사용한다
        - 에포크 타임, Epoch Time : 1970년 1월 1일 00시를 기준으로 현재까지 흘러간 시간. 단위는 초, 밀리초
    - 처음 의사 난수는 현재 시간을 seed로 사용한다
    - 다음 의사 난수는 이전 의사난수를 seed로 사용한다

### :bulb: Object 클래스
- 패키지 : java.lang - 자바의 기본이 되는 클래스들을 모아놓은 패키지 (import 선언없이 사용할 수 있다)
- 자바의 모든 클래스들의 최상위 부모클래스
* :bulb: **Object클래스의 메소드**
    - 재정의 불가능 메소드 (final키워드 적용되어있음)
	    - **notify, notifyAll, wait**   - 멀티스레드의 동기화에 사용
	    - **getClass**                  - 클래스타입으로 객체정보를 반환한다
    - 재정의 가능 메소드
        - **toString**
		    - **객체를 설명하는 문자열을 반환하는 메소드**
		    - "데이터타입@참조값" 형식의 문자열을 기본적으로 리턴한다
		    - System.out.println(객체); 메소드는 객체의 toString()을 호출하여 리턴값을 출력한다
		    - **주로 재정의하여 객체의 멤버필드값이 출력되도록 사용한다**
        - **equals**
		    - 객체의 **동등성을 비교**하는 코드로 재정의하여 사용한다
	        - 객체의 동일성을 비교하는 코드로 기본적으로 정의되어있지만, 실제 프로그래밍에서 사용할 때에는 **재정의해서 사용한다**
		    - **동일성(identity)** - 같은 객체인가, 같은 **참조값**을 가지는가
		    - **동등성(equality)** - 같은 **데이터**를 가지는가
            - String클래스는 equals()를 오버라이딩하고 있다
        - **hashCode**
		    - **객체의 고유한 값을 반환하는 메소드**
		    - 객체의 참조값을 10진수로 반환하는 것이 기본 동작이다
            - String클래스는 문자열데이터를 이용해서 hashCode()를 오버라이딩하고 있다 -> 같은 문자열이라면 같은 hashCode가 나온다
        - **clone**
		    - **객체를 복사하여 반환하는 메소드**
            - Object클래스에 protected 접근제한자로 설정되어있다
		    - 오버라이딩하여 public으로 변경하여 사용한다
            - 반환타입이 Object이므로 복사하려는 클래스로 형변환하여 사용한다
            - 예외 처리 구문(try ~ catch)이 필요하다
            - clone()메소드를 오버라이딩하는 클래스는 interface Cloneable을 상속해야만 한다
        	- 깊은 복사된 인스턴스의 참조값을 반환한다
        - **finalize**
		    - **객체가 소멸될 때 호출되는 메소드**
		    - GC(Garbage Collector)가 객체를 파괴할 때 호출되는 메소드
		    - 건들지 말 것! 재정의하지말고, 사용도 하지마세요!

### :bulb: Wrapper 클래스
- 기본 데이터타입을 **포장**하고 있는 클래스
- 기본 데이터타입의 데이터를 **객체타입**으로 사용할 수 있게 해주는 클래스들
- 기본 데이터를 **참조형 변수**로 사용할 수 있게 해준다
```java
	기본형		Wrapper클래스(참조형)

	boolean     Boolean
	char        Character (기본형과 이름 다름)
	byte        Byte
	short       Short
	int         Integer (기본형과 이름 다름)
	long        Long
	float       Float
	double      Double
```
* :bulb: **박싱, Boxing**
    - 기본형 -> 참조형
    - Wrapper클래스의 **생성자**를 이용한다
    ```java
    new Integer(123);
    ```
* :bulb: **언박싱, Unboxing**
    - 참조형 -> 기본형
    - Wrapper클래스의 **메소드**를 이용한다
    ```java
    객체변수.intValue();
    ```
* :bulb: **오토 박싱, 오토 언박싱**
    - 박싱, 언박싱이 자동으로 이루어지는 현상
    - 기본형과 참조형을 따로 구분하지 않고 사용할 수 있다
    ```java
    	Integer iVal = new Integer(123); //참조형
		int num = 456; //기본형

		int sum = iVal + num; //연산에서도 구분없이 사용한다
    ```
* :bulb: **Wrapper클래스를 사용하는 이유**
    - 기본형은 자바 클래스들의 **상속구조(계층)** 에 참여하지 못한다 -> 기본형은 Object클래스의 자식요소가 아니다
    - Wrapper클래스를 이용하여 기본형을 참조형으로 표현할 수 있게 된다
    - **기본형 데이터들을 참조형으로 사용해야 할 때 적용한다 (ex. 제네릭)**

### :bulb: String 클래스
- 패키지 : java.lang
- 문자열 표현하는 클래스
- 문자열의 데이터타입으로 사용된다
- 문자열을 다루는 기능(메소드)을 포함하고 있다
- 문자열 리터럴 상수도 String클래스 타입이다
```java
ex) "Apple" -> String타입
```
* :bulb: **문자열 객체 사용법**
    1. 리터럴 상수를 대입하여 사용하기
    ```java
	ex)	String str = "Banana";
    ```
    2. 객체를 생성하여 사용하기
    ```java
	ex)	String str = new String("Banana");
    ```
* :bulb: **String**
    - 문자열을 저장할 때마다 **새로운 공간**을 생성한다
    ```java
    String str = "Apple";
	str = "Banana";
	str = "Cherry";
    ```
    - 문자열 수정할 때에도 **새로운 공간**을 할당한다
    ```java
    String str = "Apple";
	str += "Banana";

	-> 기존의 "Apple"
	-> 추가될 "Banana"
	-> 합쳐진 "AppleBanana"
	-> 세가지 문자열이 각각 생성된다
    ```
    - 단순 문자열을 저장할 때 좋다
    - 문자열을 수정하면 성능이 좋지 않다. 메모리가 낭비되니까
* :bulb: **StringBuffer, StringBuilder**
    - 객체 내부에 문자열을 저장하는 공간을 따로 생성한다
    - 이 공간을 지속적으로 관리한다
    - **공간의 크기(capacity)도 늘리거나 줄일 수 있다**
    - **수정이나 삭제가 빈번한 문자열을 관리하기에 좋다**
    - StringBuffer, StringBuilder는 동일한 기능을 가지고 있다
    - 메소드들도 다 같은 걸 가지고 있다
    - StringBuffer **동기화 처리**되어있다 (Thread-Safe, 멀티스레드에 안전)
    - StringBuilder **동기화 처리**되어있지 않다
	    - **멀티 스레딩** 환경에서 선택하여 사용하게 된다
	    - 평소에는(싱글 스레딩) StringBuilder를 사용하면 된다
- 문자열을 저장하고 **수정, 삭제가 없으면 String**을 사용한다
- 문자열을 저장하고 **수정, 삭제가 빈번하면 StringBuilder**를 사용한다
- 문자열을 저장하고 수정, 삭제가 빈번하고 **멀티스레딩** 환경이면 **StringBuffer**를 사용한다
- [멀티스레딩이 뭔데?]()
- [동기화는 뭔데?]()

* :bulb: **문자열 토큰으로 나누기**
    - String 클래스의 **split() 메소드** 이용하기
    - StringTokenizer 클래스 이용하기
	- 토큰, Token : 문자열을 특정 구분자를 이용해서 나눈 각각의 데이터
	- 구분자, Delimiter : 데이터를 구분하기 위해 사용되는 요소


### :bulb: 자료 구조, Data Structure
- 프로그램에서 사용되는 데이터들을 효과적으로 저장하고 관리하는 전략
- 프로그램의 알고리즘(동작원리)과 어울리는 형태로 데이터를 논리적으로 배치
```java
    학생 성적관리프로그램
    -> 2명의 학생
    -> 3과목
    int[][] score = new int[2][3];
```
* :bulb: **배열, Array**
    - 가장 기본적인 형태의 자료구조
    - 데이터를 일렬로 배치한 구조를 가진다 -> 선형 구조, Linear
* :bulb: **스택, Stack**
    - LIFO, Last Input First Output, 후입선출
    - **마지막(최근)에 입력된 데이터를 가장 먼저 사용한다**
	- 메소드 Call Stack에서 사용되는 알고리즘이다
	    - Call Stack : 메소드의 호출 순서와 지역변수 공간의 관리
    - 자바에서 컬렉션의 Stack클래스를 통해 제공된다
    - 주요 메소드
        - push() : 데이터 입력
        - pop() : 데이터 출력 및 삭제
        - peek() : 데이터 확인, pop()될 데이터를 확인한다(삭제X)
* :bulb: **큐, Queue**
    - FIFO, First Input First Output, 선입선출
    - **대기열 시스템**을 구축할 때 사용한다
    - 주요 메소드
        - offer() : 데이터 입력, enqueue(인큐)
        - poll() : 데이터 출력 및 삭제, dequeue(디큐)
        - peek() : 데이터 확인, poll()될 데이터 확인(삭제X)

### :bulb: 컬렉션, Collection
- 자바에서 제공하는 기본 자료구조들을 모아놓은 것
- List, Set, Map 세가지 형태로 제공된다
* :bulb: **List 인터페이스**
    - 리스트 자료구조의 최상위 부모 인터페이스
    - 데이터를 일렬로 배치하는 자료구조 -> 선형구조
    - 요소(Element)들을 인덱스(index)로 관리한다
    - 배열은 생성되면서 요소를 저장할 수 있는 크기가 결정된다
    - **리스트는 요소가 추가될 때마다 저장공간을 확장하는 개념이다**
    - 데이터를 리스트에 추가한 순서가 유지된다
    - 배열과 유사한 구조를 가진다
* :bulb: **interface List 의 구현체 (구현된 class)**
    - **class ArrayList, 단순 연결 리스트**
	    - 배열과 거의 같은 동작을 한다
	    - 배열과 달리 요소를 저장하는 개수가 **확장 or 축소**된다
	    - **단방향 포인터**를 사용한다
	    - 단방향 포인터의 단점
	        - 중간데이터의 삭제, 중간데이터 삽입이 빈번할 경우 비효율적이다	
	    - 빠른 편이다 (배열에 비해서 크게 느리지 않다)
    - **class LinkedList, 양방향(이중) 연결 리스트**
	    - **양방향 포인터를 사용한다**
	    - 양방향 포인터의 장점
	        - 중간데이터 삭제, 삽입에 잘 어울리는 구조이다
    - **class Vector**
	    - ArrayList와 같은 구조, 같은 사용법
	    - 동기화처리 되어있다(Thread-Safe)
* :bulb: **Set 인터페이스**
    - 비선형 구조
    - **집합**
    - 데이터의 모음, 묶음
    - **데이터의 입력 순서를 유지하지 않는다**
    - 인덱스가 없음
    - **중복데이터를 허용하지 않는다** (hashcode(), equals() 를 이용하여 중복검사한다)
* :bulb: **interface Set의 구현체(class)**
    - **class HashSet**
	    - 가장 기본이 되는 Set구현체
	    - 다른 Set클래스들에 비해서 접근이 빠른 편이다
    - **class LinkedHashSet**
	    - **데이터의 입력 순서를 유지한다**
        - **인덱스는 없다**
        - [그럼 어떻게 순서를 유지한다는 거지?]()
    - **class TreeSet**
	    - **정렬 기능이 포함된 Set**
	    - 기본으로 오름차순 정렬이다
        - Set 생성작업이 **느린** 편이다
	    - 데이터를 추가하거나 삭제하는 작업이 **느린** 편이다
        - 대신, **조회(탐색)이 매우 빠른** 편이다
* :bulb: **매핑, Mapping**
    - 두 집합의 원소들 간의 **대응관계**
    - 데이터와 데이터사이의 관계
    - 일대일 매핑 (one to one, 1:1)
    - 일대다 매핑 (one to many, 1:m)
    - 다대일 매핑 (many to one, m:1)
    - 다대다 매핑 (many to many, m:n)
* :bulb: **Map 인터페이스**
    - 매핑된 데이터를 관리한다
    - **Key, Value 두 데이터를 한 쌍(Entry)으로 묶어 데이터를 관리한다**
    - 맵에는 여러 쌍의 데이터를 저장할 수 있다
    - Key는 데이터쌍(Entry)의 기준값으로 사용한다 (데이터의 식별값)
    - Value는 데이터쌍(Entry)의 Key에 대응하는 값 (매핑된 값, 데이터)
    - Key는 중복값 사용 불가
    - Value는 중복값 사용 가능
* :bulb: **interface Map의 구현체(class)**
    - **class HashMap**
	    - Map의 기본 동작을 구현한 클래스
	    - **key중복검사에 hashCode()를 사용한다**
	    - hashCode()가 같고 equals()가 true일 때 같은 키값으로 판단한다
    - **class Hashtable**
	    - HashMap과 같다
	    - 동기화처리 되어있다
    - **class Properties**
	    - Hashtable의 하위 클래스
        - 키(key)와 값(value)이 String으로 제한되어있다
	    - 주로 프로그램의 설정값을 저장하는 용도로 사용한다
	    - 옵션정보, DB연결 정보, 다국어 정보(Locale) 등으로 사용한다
	    - 키=값 쌍(entry)을 파일에 저장하고 불러올 수 있다
	    - 주로 확장자를 .properties로 다룬다

### :bulb: 일반화 프로그래밍
- 자료형을 일반화시켜 프로그래밍하는 것
```java
	int	===일반화==>	데이터타입 T
	double
	float
	boolean
	String
	Point
	Person
	...
```
- 자바에서는 제네릭(Generic)을 이용하여 일반화 프로그래밍이 구현된다
```java
ex)
public void print(int data) {
  System.out.println("데이터 : " + data);
}
public void print(double data) {
  System.out.println("데이터 : " + data);
}
public void print(Point data) {
  System.out.println("데이터 : " + data);
}
public void print(float data) {
  System.out.println("데이터 : " + data);
}
-> 같은 이름, 같은 동작을 하는 코드를 "데이터타입"만 다르게 여러 개 작성됨
---------------------------------
public <T> void print(T data) {
  System.out.println("데이터 : " + data);
}
-> 데이터타입을 일반화시켜 표현하고 중복으로 작성되는 코드를 줄인다
```
* :bulb: **제네릭, Generic**
    - 클래스 또는 메소드에서 사용되는 **다양한 데이터타입을 일반화**시켜 프로그래밍을하는 방법이다
    - **데이터타입만 달라지며 똑같은 코드(중복된 코드)를 작성해야하는 경우를 줄여준다**
	    - 코드 재사용성이 높아진다
    - 타입 안정성을 제공한다
	    - **개발자가 원하는 데이터타입만 사용할 수 있도록 제한할 수 있다**
	    - 다른 데이터타입을 사용하면 문법 에러가 발생한다
    - 특정 데이터타입으로 고정하여 사용하므로 불필요한 형변환이 줄어든다
* :bulb: **자주 볼 수있는 제네릭 문자**
    - T - Type
    - E - Element
    - K - Key
    - V - Value
    - N - Number
* :bulb: **제네릭 클래스**
    - 제네릭타입이 적용된 클래스
    ```java
    [접근제한자] class 클래스명<TYPE1, TYPE2, TYPE3, ...> {

	}
    ```
    - **제네릭 클래스를 이용하여 객체를 선언하고 생성할 때 타입 파라미터를 결정해주는 것이 좋다**   
    -> 타입 파라미터를 명시하지 않으면 Object타입으로 자동 결정된다
* :bulb: **제네릭 메소드**
    - 메소드 내에서 **사용할 수 있는 데이터타입을 일반화**시켜 정의한다
    ```java
	[접근제한자] <TYPE1, TYPE2, ...> [리턴타입] 메소드명(매개변수) {

	}
    ```
    - 리턴타입, 매개변수타입, 지역변수타입으로 제네릭 사용 가능하다
    - **메소드를 호출하면서 파라미터의 데이터 타입을 결정할 수 있다**   
    -> **전달인자의 데이터 타입에 따라 자동으로 결정되도록 할 수 있다**

### :bulb: 프로그램의 개발 오류, 에러(Error)
1. **컴파일 타임 에러, Compile-time Error**
    - 컴파일 시점에 발생하는 에러를 뜻한다 (이클립스에서는 소스코드를 저장하는 즉시)
    - 주로 문법 에러를 뜻한다(Syntax Error)
2. **런타임 에러, Runtime Error**
	- 프로그램 실행 도중 발생하는 에러
    - 수행할 수 없는 작업을 시도할 때 발생한다
3. **논리 에러, Logical Error**
	- 프로그램이 에러 발생없이 정상적으로 동작한다
    - 개발자가 의도한 대로 프로그램이 동작하지 않는 것을 뜻한다
    - ex) (의도하지않은) 무한 루프
* :bulb: **Throwable 클래스**
    - 런타임에러를 정의하고 있는 클래스들의 부모클래스
    - Error 클래스, Exception 클래스 들을 자식클래스로 가진다
* :bulb: **Error 클래스, 에러**
    - 심각한 수준의 오류
    - 복구가 안되는 수준의 문제 상황
    - 프로그램이 무조건 중단된다
    - 프로그램의 코드(자체적인 방법)로 해결할 수 없는 수준의 오류
    - ex) OutOfMemoryError -> 메모리가 부족한 상황에서 할당을 시도한 상황
* :bulb: **Exception 클래스, 예외**
    - 프로그램이 실행되는 동안 발생하는 **예외적인 상황**
    - 개발자가 예외 상황을 예측해서 프로그램 로직(코드)으로 처리 가능한 수준의 런타임 오류를 뜻한다
    - 논리적으로 예상 가능했던 상황이다 -> **try-catch** 구문을 이용하여 "예외 처리" 작업을 한다.
    - **예외 처리, Exception Handling : 발생할 수도 있는 예외적인 상황에 미리 대비하는 코드를 작성하는 것**
* :bulb: **예외 처리 구문, Exception Handling**
    - **try ~ catch 구문**
    ```java
    try {
	  //예외가 발생할만한 코드
	} catch( Exception e ) { //발생할 예외 클래스로 적는 게 좋다
	  //예외 처리 코드 작성
	} finally {
	  //예외 발생 유무에 상관없이 무조건 실행되는 코드를 작성한다
	  //생략 가능한 블록
	}
    ```
* :bulb: **throw 키워드**
    - 개발자가 직접 예외를 발생(throw)시키기 위해 사용하는 키워드
    - 사용법
    ```java
    [throw new] [예외클래스]();
    throw new NullPointerException();
    NullPointerException e = new NullPointerException();
    ---
	[throw] [예외객체];
    throw e;
    ```
* :bulb: **Checked Exception**
    - Exception의 하위클래스들 중에서 RuntimeException의 하위클래스들을 제외한 클래스들 ( Other Exceptions )
    - **반드시 예외처리구문(try-catch)을 사용해야한다**
    - 예외처리코드를 적지 않으면 문법에러(컴파일타임에러)가 발생한다
        - quick fix : surround with try-catch
    - 실행단계가 아닌 코드 작성단계에서 미리 체크해서 예외처리구문을 작성해야 한다
* :bulb: **Unchecked Exception**
    - RuntimeException의 하위 클래스들
    - 반드시 **예외처리하지 않아도 된다**
    - 프로그램 실행 도중 발생한 예외를 확인한 후에 예외처리를 하게 된다
* :bulb: **throws 키워드**
    - **예외 처리 떠넘기기, 예외 처리 미루기**
    - 예외가 발생한 메소드에서 자신이 예외를 처리하지 않고, **자신을 호출한 메소드에게 예외 처리를 미루는 키워드**
    - 예외가 발생하는 상황에 대한 책임을 메소드를 호출한 쪽(Caller)에게 맡기는 방식
    - main()메소드에는 throws를 적용하지 않는 것이 좋다
    - 사용 방법
    ```java
	[접근제한자] [식별자] [리턴타입] 메소드명(매개변수) throws 예외클래스 {

	}
    ```
	- 메소드 정의코드에서 ()괄호 부분과 { 사이에 적어준다
* :bulb: **사용자 정의 예외 클래스 만들기**
    - API로 제공되는 예외클래스들 이외의 추가적인 예외 클래스를 작성할 수 있다
    - 예외 상황을 프로그램에 맞게 정의하고 클래스로 구현한 것
    - Exception클래스를 상속받아 구현할 수 있다 -> Checked Exception이 만들어진다
    - RuntimeException클래스를 상속받아 구현할 수 있다 -> Unchecked Exception이 만들어진다

### :bulb: 입출력, Input/Output, I/O
- 프로그램이 입출력장치와 데이터를 송/수신하는 것

### :bulb: 스트림, Stream
- **데이터의 통로, 데이터의 흐름**
- 입출력 장치와 프로그램 사이에서 데이터를 통신(교환)할 수 있도록 제공되는 SW적인 장치
- **단방향**이다
    - ( 입력스트림-->프로그램 )
    - ( 프로그램-->출력스트림 )
- **FIFO구조**로 되어있다 
- 기본적으로 **바이트 단위로 통신**한다
- **버퍼(Buffer)** 를 가지고 있다
    - 버퍼, Buffer : 데이터 임시 저장소
* :bulb: **스트림의 분류**
    1. 입출력 구분
        - 입력 스트림
        - 출력 스트림
    2. 연결 대상을 기준으로 구분
        - 1차 스트림 : 입출력장치와 **직접** 연결되는 스트림
        - 2차 스트림 : 1차스트림과 연결되어 추가(보조)기능을 제공하는 스트림
    3. 전송 데이터 형태에 따른 구분
        - 바이트 스트림 : 바이트(1B) 단위로 통신한다
        - 문자 스트림 : 문자(char, 2B) 단위로 통신한다
    4. 기능에 따른 구분
        - 보조 스트림 : 직접 입출력하는 기능이 없지만, 다른 스트림의 기능을 향상시킨다
* :bulb: **입력스트림의 기본 클래스(부모 클래스)** : class InputStream (java.io)
* :bulb: **출력스트림의 기본 클래스(부모 클래스)** : class OutputStream (java.io)
* :bulb: **InputStream의 read메소드**
    - 입력스트림에서 최대길이로 매개변수인 **b배열의 길이(length)만큼 데이터를 읽어들인다**
    - 읽어들인 데이터를 매개변수로 전달한 b배열에 저장한다
    - 읽어들인 데이터의 길이를 int형으로 반환된다
    - 읽어들일 데이터가 없을 경우 -1 을 반환한다
        - 읽어들일 데이터가 없는 상황 == End Of Stream
        - EOF, End Of File == End Of Stream
```java
public int read(byte[] b) throws IOException
```
* :bulb: **OutputStream의 write메소드**
    - b배열의 off인덱스부터 시작하여 **len길이만큼 출력스트림으로 출력한다**
    - b배열의 데이터가 출력 버퍼에 전송(출력)된다
```java
public void write(byte[] b, int off, int len) throws IOException
```
* :bulb: **보조스트림, FilterStream**
    - FilterInputStream : 바이트 입력스트림의 보조스트림 클래스
    - FilterOutputStream : 바이트 출력스트림의 보조스트림 클래스
* :bulb: **BufferedStream**
    - 클래스 내부에 버퍼를 가지고 있는 스트림
    - 입출력스트림의 **입출력횟수(read(), write())를 줄여 성능 향상**을 유도한다
    - 기본적으로 사용되는 보조스트림이다 -> 스트림을 다루면 거의 항상 사용한다
* :bulb: **DataStream**
    - **자바 기본자료형으로 형식을 유지**하면서 입출력하도록 기능을 제공한다
    - 자료형에 맞는 입출력 메소드가 제공된다
* :bulb: **ObjectStream**
    - **객체 단위로 입출력**할 수 있도록 기능을 제공한다
    - DataStream의 기능을 모두 사용할 수 있다
    - ArrayList같은 컬렉션도 객체형태를 유지하면서 입출력할 수 있다
    - 입출력에 사용되는 객체는 직렬화가능 클래스여야 한다 -> interface Serializable 상속
* :bulb: **직렬화, Serialization**
    - **크기가 큰 데이터(객체)를 바이트단위로 잘게 나누어서** 스트림을 통과할 수 있도록 만드는 것
* :bulb: **역직렬화, Deserialization**
    - 바이트단위로 잘게 나누어져(직렬화되어) 스트림을 통과한 데이터를 **원본의 형식(객체)으로 다시 합치는 것**
* :bulb: **스트림의 종류**
```java
	    바이트 스트림               문자 스트림
	    ------------------------    ------------------------
(기본)      InputStream                 Reader
	    OutputStream                Writer

(성능)      BufferedInputStream         BufferedReader
            BufferedOutputStream        BufferedWriter

(파일)      FileInputStream             FileReader
             FileOutputStream            FileWriter
	    ------------------------	------------------------
            //바이트 스트림만 존재한다
(자료형)    DataInputStream
            DataOutputStream

(객체)      ObjectInputStream
            ObjectOutputStream
	    ------------------------	------------------------
	    //바이트스트림을 문자스트림으로 변환한다
					InputStreamReader
					OutputStreamWriter
	    ------------------------	------------------------
	    //문자 출력 스트림의 기능을 강화해놓은 클래스
					PrintStream
```

### :bulb: 경로
* :bulb: **절대 경로, Absolute Path**
    - 루트(root) 디렉토리로부터 파일까지의 **모든 경로**를 나타내는 방법
    - 루트 디렉토리 == 최상위 폴더
    - 윈도우OS는 "드라이브문자:\" 로 표현한다
    - 맥OS는 "/" 로 표현한다
    - ex) "D:\\Test\\folder\\file.txt"
    - ex) "E:/hi/hello"
    - ex) "/folder/file.txt"
* :bulb: **상대 경로, Relative Path**
    - 프로그램이 실행된 위치(경로)를 기준으로 파일의 위치를 상대적으로 표현한다
    - 클래스 패스, Class Path
	    - 프로그램이 실행된 위치(경로)
        - 이클립스로 프로그램을 실행할 경우 프로젝트 폴더를 클래스패스로 설정한다
    * **프로그램에서는 절대경로보다 상대경로를 사용하도록 한다**
        - 개발 환경과 실행 환경이 달라지면 절대 경로의 기준으로 지정한 위치가 존재하지 않을 수 있다
        - 완성된 프로그램이 배포되어 실행되는 환경에서 문제없이 동작해야 한다
        - 프로그램(프로젝트)의 내부를 기준으로 상대 경로를 지정하여 프로그램을 개발하도록 한다
    * **경로 지정 문자**
        - 상대 경로나 절대 경로를 표현할 때 사용하는 디렉토리 지정 문자
        ```java
            .	-> 현재 디렉토리
            ..	-> 부모 디렉토리
            /	-> 루트 디렉토리 (최상위 디렉토리)

            ex)	"D:/workspace/JavaBasic" 경로에서 작업 중일 경우
                -> "/test.txt"	        - "D:/test.txt"
                -> "./"			    - "D:/workspace/JavaBasic"
                -> "../"		    - "D:/workspace"
                -> "../././../"		    - "D:/"
        ```

### :bulb: 네트워크, Network
- 노드(node)들의 연결망(통신망)
- 통신망에서의 노드: 네트워크로 연결된 시스템들 -> 컴퓨터, 주변장치, 네트워크장비, 모바일기기, 스마트기기 등등
* :bulb: **노드의 구분**
    - **서버, Server : 다른 노드에게 서비스(기능)를 제공하는 노드**
    - **클라이언트, Client : 서비스를 이용하는(제공받는) 노드 (역할에 따라 노드를 구분한다)**
    - 전용 서버를 두는 방식을 CS방식이라고 한다
    - 각 노드가 서버, 클라이언트 역할의 구분이 없으면 P2P방식이라고 한다
* :bulb: **프로토콜, Protocol**
    - 통신 규약
    - **노드들이 통신(데이터 교환)할 때 지켜야할 규칙을 정해놓은 것**
    - 통신 방식(절차), 전송하는 데이터의 형식, 노드의 위치(주소) 등을 정의한다
    - 대표적으로 TCP/IP Protocol 이 있다
* :bulb: **TCP/IP Protocol**
    - Transmission Control Protocol / Internet Protocol
    - TCP : 연결 제어 프로토콜 -> 통신 방식
    - IP : 노드 위치 프로토콜 -> 인터넷 주소(IP)
* :bulb: **TCP, 연결 제어 프로토콜**
    - 네트워크를 통해 전달되는 **데이터를 작은 조각으로 나누거나 재조립**하는 방식을 정하고 있다
    - 잘게 나눈 데이터 조각을 **패킷**이라고 한다
    - 한번에 큰 용량의 데이터를 전송하는 것이 현실적으로 부적절하므로 패킷단위로 잘게 나누어 전송한다 -> 통신망을 독점하게된다
    - 패킷마다 순서(번호)를 붙여 전송한다
    - 전송방식에 따라서 TCP방식, UDP방식으로 나눈다
* :bulb: **TCP vs UDP**
    - 패킷을 전송하는 방법(전략)이 다르다
    - TCP : 연결지향적, 신뢰성 있는 통신, **안정성↑**
    - UDP : 비연결지향적, 신뢰성 없는 통신, **속도↑**, 실시간 통신
	- 연결지향 : 송수신장치 사이에 연결이 먼저 수립된 후 데이터 통신
	- 비연결지향 : **연결없이** 한쪽에서 다른 쪽으로 데이터 **통신**
* :bulb: **IP, Internet Protocol**
    - 인터넷 프로토콜
    - **노드의 위치**를 표현하는 방법을 정의한 통신 규약
    - **패킷이 전송될 곳을 구분할 수 있게 해준다**
    - 패킷마다 전송될 장소의 IP가 부여된다
* :bulb: **TCP/IP 프로토콜에서 사용하는 주소 체계**
    - **IP Address**
        - 네트워크 상에서 각 노드의 위치를 나타내는 주소 체계
	    - IP Protocol에 형식이 정의되어 있다
	    - **32bit** DWORD타입으로 표현한다 (DWORD == 부호없는 정수 == 양수만 표현)
	    - 32bit를 1B단위로 4자리로 나눠서 표현한다
	    - 0-255.0-255.0-255.0-255
	    ```java
        ex)	192.168.10.3
		    win키 + r   (실행창)
		    cmd         (콘솔창)
		    ipconfig    (맥OS는 터미널에서 ifconfig)
        ```   
    - **Port Address(Number)**
        - **노드 안에서 서비스의 위치를 구분하는 주소**
	    - **어떤 프로그램인지 구분하는 주소**
	    - TCP Protocol에서 형태를 정의한다
	    - **16bit** WORD타입으로 표현된다 (WORD == 부호없는 정수)
	    - 0~65535 내에서 정수값으로 사용된다
	    - **IP주소 뒤에 : 을 붙이고 추가 적용해서 나타낸다**
	    ```java
        ex)	192.168.10.3:8801
		    IP : 192.168.10.3
		    Port : 8801
        ```     
    - **Well-Known Port, 잘 알려진 포트번호**
        - 0번 ~ 1023번
	    - 자주 사용되는 서비스(기능)에 일반적으로 사용하는 포트번호
	    - **80 - 웹 서비스, HTTP**
	    - **443 - 보안 웹 서비스, HTTPS**
* :bulb: **소켓, Socket**
    - SW적으로 구현된 통신의 **접속지점**, 가상 장치
    - 자바에서는 클래스API로 제공된다
    - **통신에 필요한 절차를 프로그램에서 직접 구현하지 않고 바로 통신할 수 있도록 개발된 API**
* :bulb: **소켓 클래스의 종류**
    - 서버용 소켓 : ServerSocket class
    - 클라이언트용 소켓 : Socket class
    ---