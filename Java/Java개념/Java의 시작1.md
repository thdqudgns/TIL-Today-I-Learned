# :pushpin: Java의 시작

### :bulb: **객체지향 프로그래밍, OOP(Object Oriented Programming)**
- 객체들을 중심으로 상호작용(데이터 전달, 교환)을 통해 프로그램이 작동되도록 작성하는 프로그래밍 기법
- 객체마다 **고유의 기능**이 있다. 이 기능은 각각 스스로 활용할 수 있다. 그러나 다른 기능을 이용하려면 통신을 해야 한다
- **Q: 객체마다 어떤 고유의 기능이 있는가? Q: 그 기능을 어떻게 만드는 것인가?**
- 객체는 '같은 기능을 가진 집합체'라고 말할 수 있다.
- 객체의 큰 목적 중의 하나가 '현실세계를 반영'하자는 것이다.
- 프로그램 코드를 일부 명령어들의 나열로 보지 말고, 명령어들의 **집합체**(=객체)를 중심으로 생각하자. 작게 보지 말고 크게 묶어서 보자.
- Why? 절차지향프로그래밍(Procedural Programming) : 이것은 코드가 순차적으로 실행된다. **순차적으로 실행될 때의 단점**은 무엇일까? 만약에 코드의 밑에서 **이전에 실행했던 기능을 사용한다면 코드의 위로 올라갔다가 다시 밑으로 내려오거나, 이전의 코드를 현 위치에서 그대로 다시 써내려가야 한다.** 이런 복잡함을 해결하기 위해 **기능이 있는 코드를 처음부터 따로 생성하여, 불러오는 방식**이 객체지향 프로그래밍이다.
#### :bulb: **객체, Object**
- 현실 세계에 존재하는 모든 것들.
- 프로그램에서 구현(표현)하고자 하는 모든 대상. 이것을 객체라고 본다
#### :bulb: **클래스, Class**
- 객체를 만들기 위해서 코드로 작성한 것
- 객체(현실대상을)를 추상화한 것
    ```java
    	[접근제한자] [클래스식별자] class [클래스명] {
		    //멤버 필드
		    //멤버 메소드
	    }
        public final class className { //클래스 식별자는 없어도 됨
            private int num = 10;
            private String word = "name";
            public void methodName (parameter) {
                //code
            }
        } 
    ``` 
#### :bulb: **추상화, Abstraction**
- **수많은 데이터 중에서 필요한 데이터만 선별한 것**
    ```java
        ex)
        프로그램 목표 : 주소록(이름, 전화번호, 주소)
        
        객체(현실세계 대상)
        -> 사람의 데이터
            이름 *
            나이
            출생지
            주민번호
            전화번호 *
            주소 *
            학력
            친구목록
            ...
            
        수많은 데이터들이 있어도 필요한 것은 소수다.

        전체 데이터 중에서 필요없는 데이터는 버리고
        필요한 것만 선택해오는 것을 "추상화"라고 한다
    ```
- 객체에는 너무 많은 정보가 있다. 필요없는 정보도 있다. 여기서 필요한 데이터만 뽑아서(추상화해서) 클래스를 만드는 것이다.
    ```java
                                            (인스턴스화)
                        (추상화)             (객체 생성)
        현실 세계 대상 -------------> 클래스 -------------> 객체, Object
        (객체, Object)               (class)                (Instance)
                                                            메모리에 저장된 정보를 의미
    ```
- 현실의 정보(객체)를 필요한 것만 코드로 작성(클래스)하여 프로그램 안에 저장(인스턴스)시킨다
- class의 이름은 그 정보의 주제로 한다
- 프로그램으로 아직 만들지 않은 정보도 '객체'라 부르고, 프로그램으로 만든 것도 '객체'라고 부른다. 그러나 프로그램 안의 객체는 '인스턴스'라고도 부른다.
- (현실세계대상)객체의 공통적인 속성, 기능, 행위 등을 개념화하는 작업
- 프로그램에서 필요한 요소들만 집중해서 정리해야 한다. **프로그램에서 필요로 하지 않거나 중요하지 않은 요소는 무시한다**
#### :bulb: **인스턴스, Instance**
- 메모리에 생성된 **객체**
- **클래스(class) 코드를 통해서 생성된 실체(객체)**
- **new가 메모리에 인스턴스 공간을 생성하는 코드다** 그러면 이제 변수가 이 공간을 참조하는 것이다
#### :bulb: **인스턴스화, Instantiate**
- 인스턴스로 **만드는 것**
- 메모리에 실제화하는 **작업**
- 메모리를 차지하게끔 **공간을 생성하는 것**
    ```java
            클래스 -----> 인스턴스(객체)
            (코드덩어리)    (메모리를 차지하는 실제 공간)
            (자료형)        (변수)
            (건축설계도)    (건물)
    ```

#### :bulb: **접근제한자, Access Modifier**
- **private, default(package), protected, public**
- 사용 목적: 현실세계의 객체에서 컴퓨터의 클래스로 정보가 이동할 때 **추상화**가 있었다. **그래서 꼭 있어야 하는 정보만 클래스에 있다.** 클래스에 있는 정보는 중요하게 다뤄진다. 클래스에 있는 '멤버필드'와 '멤버메소드'는 중요하다. 지워지면 안 되므로 **안전하게 보관**하려고 했다.
- 그런데 이를 일반 변수로 설정하면 누구나 접근이 가능하니까 보안을 높여서 접근을 제한하려고 한다. 그래서 접근제한자를 만들었다. 클래스의 정보를 보호하기 위해.
- 객체의 멤버필드(고유한 속성), 멤버메소드(고유한 동작과 기능)에 대한 **정보를 외부에 함부로 공개하지 않기 위해 사용한다.** (이런 여러 개념들의 사용목적을 알면 활용도가 높아지고, 면접 때도 물어본다)
- 객체는 추상화 이후의 결과물이 된다. -> 프로그램에서 중요한 정보만 추출한 것
- 객체의 멤버를 외부에서 함부로 접근하면 프로그램에 악영향을 끼칠 수 있다. 그래서 안전하게 써야 한다. 외부 접근을 차단하려고 한다. -> 모두 막는 건 아님. 일부는 열고 일부는 닫는다.
- 필요한 정도까지만 멤버를 공개하고, 나머지는 제한한다.
- **접근제한자의 종류**
    - 종류에 따라 정보를 공개하는 정도가 달라진다
    - **private(-)** : 해당 **클래스 내부에서만 접근 가능.** 바깥쪽에서는 뭐가 있는지도 모른다.
    - **default** : **같은 패키지 안에서만 접근 가능.** 같은 패키지의 클래스들끼리 상호작용하게 함. 같은 기능, 같은 목적을 지닌 클래스들끼리 한 패키지에 묶음. (키워드 X, 변수 앞에 아무것도 안 적으면 적용된다)
    - **protected(#)** : **같은 패키지 + 상속 관계의 객체까지 접근 가능.** 다른 패키지라도 상속 관계면 접근 가능하다
    - **public(+)** : 모든 접근 허용
- **공개범위** : **private < default < protected < public**
- **접근제한자를 적용할 수 있는 위치**
    - **멤버 필드** : 4가지 전부 적용가능 (주로 private을 적용)
    - **멤버 메소드** : 4가지 전부 적용가능 (주로 public을 적용)
    - **클래스 정의코드** : public 또는 default

#### :bulb: **메소드, Method** = 객체의 기능
- 함수, function <- 객체의 의미보다 포괄적이다. 자바는 객체로 구성되어 있기 때문에 특정 기능을 객체라고 부르는 것이 함수보다는 어울린다. 그러나 '기능'을 하는 것은 같기에, 큰 차이는 없다.
- 클래스(객체)의 기능, 동작, 행위 등을 정의하는 코드
- **메소드를 사용하려면 객체 변수를 통해서 호출해야 한다**
- **객체들 간의 데이터 전달 수단**
    ```java
            [접근제한자] [리턴타입] [메소드명] ( 매개변수 ){
            (*주로 public)         (*소문자 시작)
                //실행 코드	        
            }
            public void methodName (parameter) {
                //code
            }
    ```
- 자바의 메소드를 호출할 때 전달인자로 절대! 변수공간을 전달하지 않는다.    
    - 변수에 저장되어 있는 '값'만을 복사하여 전달한다
	- 전달되는 값의 자료형은 참조형일 수도 있고 기본형일 수도 있다.
- **Call By Value, 값에 의한 호출**
        메소드 호출시, 전달되는 인자의 값이 **기본형 데이터**일 때
- **Call By Reference, 참조에 의한 호출**
        메소드 호출시, 전달되는 인자의 값이 **참조형 데이터**일 때
- Call By Value 상황에서는 매개변수의 값을 변경해도 **원본(메인메소드의 변수)은 그대로 유지**된다. Call By Reference 상황에서는 매개변수를 통해서 참조한 공간의 값을 변경하면 **원본에서도 변경된 데이터**를 확인할 수 있다. -> 참조값만 복사되는 얕은복사(Shallow Copy)가 된 상황이다.
- **메소드에서 return코드의 역할**
    1. 반환값 지정하기
	2. 메소드 종료하기
- 반환 데이터타입이 void일 경우 반환값을 지정할 수 없다.
	- return; <- 이렇게만 사용할 수 있다. 바로 세미콜론으로 마무리.
	- 반환값 없이 메소드 종료시키는 역할만 수행할 수 있다.
- 우리가 계속 쓰는 'main()메소드'의 반환타입이 void이므로 return; 코드 사용이 가능하다.

#### :bulb: **클래스, class**
- **클래스의 접근제한자**
    - public 또는 default(안 붙이는 것)
	- public 접근제한자 적용 : **어디에서든지 사용**할 수 있는 클래스가 된다. '.java' 파일 안에는 딱 하나의 클래스만 public을 붙일 수 있다. '.java' 파일의 이름과 클래스명이 같아야 한다. -> public클래스는 해당 '.java'파일의 주된 클래스가 된다.
    - default 접근제한자 적용 : **같은 패키지에서만 사용**할 수 있는 클래스가 된다. public클래스의 보조기능을 담당하는 클래스를 만들 때 사용한다. 요즘에는 default클래스를 안쓴다. 보조기능도 그냥 public으로 만들고 패키지로 묶는다. 클래스를 엄청 많이 만든다. 5~60개.
- **클래스 식별자(제한자, modifier)**
    - 클래스의 용도에 따라서 특별 기능을 부여할 때 사용한다.
    - abstract, final, static 등등...
- **클래스명**
    - 첫 글자를 대문자로 시작
- **멤버 필드 (클래스를 사용하는 이유1)**
    - 클래스 코드를 구성하는 변수, 상수 (but, 주로 변수)
    - 설계도. 실제 공간이 만들어지는 시기는 인스턴스화 할 때이다.
    - 객체가 생성될 때, 각각의 인스턴스(객체)마다 변수공간을 만들어 준다. 이때 변수가 된다!
    - 즉, 객체를 생성하기 전까지는 실제 공간이 없는 것이다.
- **멤버 메소드 (클래스를 사용하는 이유2)**
        - 객체의 기능, 행위를 정의한 코드
- **멤버필드**와 **멤버메소드**가 있어야 클래스가 된다. + 기본으로 **생성자**도 있음

#### :bulb: **객체변수**
- 선언
    ```java
    [클래스명] [객체변수명];
	ex) Test t1;
    ```
- 생성
    ```java
    [객체변수] = new [클래스명]();
	ex) t1 = new Test();
    ```
- 객체의 멤버에 접근
    ```java
    [객체변수].[멤버필드];
	[객체변수].[멤버메소드]();
	ex) t1.num = 100;
		t1.print();
    //'.' 참조연산자를 이용하여 멤버에 접근한다
    ```

#### :bulb: **캡슐화, Encapsulation** <- 클래스의 큰 특징
- 객체지향프로그래밍의 특징 중 하나. 클래스를 캡슐화해서 만든다.
- **객체의 속성과(멤버필드) 기능(멤버메소드)을 하나의 클래스로 묶어 표현한다.**
- 프로그램에 필요하고 중요하고 서로 연관 있는 데이터와 기능들을 추출해서 하나의 클래스에 모아놓는다 = 추상화 + 캡슐화 (꼭 하나의 클래스에 작성하는 것은 아니다. 여러 클래스일 수도 있다)
- 객체를 표현하는 **정보**(데이터, 멤버필드)와 정보들을 다루는 **기능**(멤버 메소드)을 같은 클래스로 묶어서 정의한다.
- 속성(필드)은 중요한 정보이므로 외부에 함부로 공개하지 않도록 처리한다
	- 정보은닉, Information hiding
	- 필드에 접근제한자를 적용하여 처리한다
    - 캡슐화 개념 안에 정보은닉이 있다
- **멤버필드는 private을 적용한다**
- **멤버메소드는 public을 적용한다** - getter, setter 메소드를 통해 private로 은닉되어 있는 필드에 접근한다
#### :bulb: **Getter Method**
- 멤버필드의 값을 "가져올" 수 있도록 작성한 메소드
- 작성할 때 규칙: 메소드의 이름을 반드시 "get"으로 시작하고, 멤버필드명 첫 글자만 대문자로 바꿔서 사용한다
- 형식	
	```java
        public [필드의 자료형(리턴타입)] getXxxx(){
	        return [필드명];
	    }

        ex) private int num; 
        //추상화를 거친 중요한 정보이기에 접근제한자 private로 은닉된 멤버필드

	    public int getNum() { 
            //1. 멤버메소드라서 public으로 시작
            //2. 필드의 자료형이 int형이라서 그대로 따라 씀. 
            //3. getter메소드를 이용하려고 하기에 이름 명명 규칙 따라서 getNum()으로 작성
	        return num; //가져오자! private로 은닉된 num을!
	    }
    ```
#### :bulb: **Setter Method**
- 멤버필드의 값을 "저장"할 수 있도록 만든 메소드
- 메소드명을 "set"으로 시작하고, 멤버필드명 첫 글자만 대문자로 바꿔서 사용한다.
- 형식
    ```java
        public void setXxxx([필드의 자료형] [필드명]) {
            this.[필드명] = [필드명];
        }

        ex) private int num; 
        //추상화를 거친 중요한 정보이기에 접근제한자 private로 은닉된 멤버필드

        public void setNum(int num) {
            //1. 멤버메소드라서 public으로 시작
            //2. 그 다음에 void를 쓰는 것이 기본
            //3. setter메소드를 이용하려고 하기에 이름 명명 규칙 따라서 setNum()으로 작성
            //4. 형식을 따라 자료형과 변수명을 쓴다
            this.num = num; //여기 클래스에 있는 private로 은닉된 멤버필드 num에 매개변수(인자)로 받은 num을 저장하겠다!
        }
    ```
- **this 키워드(자기 참조 객체)**
    - 클래스를 정의하는 코드에서 클래스 자기 자신을 나타낼 때 사용한다. 'this.'을 이용하여 자신의 멤버필드, 멤버 메소드를 지칭할 수 있다.
- Source 메뉴를 팝업으로 띄우는 단축키 : alt + shift + s
- getter, setter 띄우는 단축키 : alt + shift + s 후 r

#### :bulb: **클래스에서 사용되는 변수의 유형**
- **인스턴스 변수, Instance Variable (파란색 글자)**
    - 일반적인 '멤버 필드'에 의해서 만들어진 변수.
    - 객체 생성(인스턴스화)하면 각 인스턴스마다 변수공간을 따로 가진다
- ***클래스 변수, Class Variable (기울인 파란색 글자)***
    - static키워드를 적용한 '멤버필드'에 의해서 만들어진 변수. 
    - 클래스변수의 변수공간은 클래스당 단 "한 개"만 만들어진다. (인스턴스마다 만들어지지 않는다) 
    - 프로그램이 동작하기 전에 미리 클래스 영역에 생성한다
    - 같은 클래스타입으로 만든 객체들이 모두 같은 하나의 공간을 공유한다
    - 접근할 때 [클래스명.클래스변수] 형식을 사용한다 = static way
    - (우리의 개발과정에서는 클래스변수를 거의 사용하지 않을 것이다 그러나 API에서는 많이 제공된다)
- **지역 변수, Local Variable (갈색 글자)**
    - 메소드 내에서 선언된 변수 = 메소드명(){ } 에서 { }안에서 선언된 변수
	- 그동안 main 메소드 안에서 변수를 선언하고 생성한 것이 이것이다
        ```java
            매개변수도 지역변수로 취급한다.

            접근제한자를 적용할 수 없다. 숨기고 말고 그럴게 없다.
            어차피 밖에서 사용할 수 없다.
            그러나 매개변수를 통해 return하여 
            값만 이동시킬 수는 있다

            메소드가 호출될 때마다 각자의 공간을 생성하고 
            그 안에 지역변수를 저장한다
            (Stack Memory 영역)

            초기화하지 않으면 쓰레기값을 가지게 된다
        ```

#### :bulb: **static 키워드**
- 클래스의 멤버를 객체 생성없이 사용할 수 있게 해주는 키워드
- 멤버 필드, 멤버 메소드 모두 적용할 수 있다
- 인스턴스와는 무관하게 사용할 수 있다
- 클래스단위로 제어한다
- 정적인 시점에 사용 준비가 완료된다
    - 정적인 시점 : 프로그램 동작을 준비하는 시점, 코드 실행 전
- 정적 멤버필드 : 클래스 영역에 변수공간을 생성한다
- 정적 멤버메소드 : 곧바로 실행 가능하도록 모든 준비를 마친다
- 특이사항
    - 정적(static)메소드에서 인스턴스변수 사용 불가
    - 정적(static)메소드에서 정적 변수만 사용 가능
    - 일반 메소드에서 인스턴스변수, 정적(static)변수 둘 다 사용 가능

#### :bulb: **생성자, Constructor**
- 생성자의 접근제한자는 보통 public이지만, private와 default가 쓰이는 경우도 있다.
- 멤버필드와 멤버메소드가 없어도 생성자는 필요하다. **클래스를 구성하는 요소다**
- **클래스에는 한 개 이상의 생성자가 반드시 있어야 한다. 수동으로 추가하지 않아도, JVM이 default생성자를 자동으로 하나 추가한다.** 그래서 존재를 몰랐던 것이고, 에러가 안났던 것이다. 그러나 클래스에 하나라도 개발자가 정의한 생성자가 있으면, JVM이 자동으로 default 생성자를 추가하지 않는다.
- 기본적인 생성자의 {}안에는 아무것도 적지 않는다. 생성자는 아무런 역할을 하지 않는다. 존재만 한다. = default 생성자 (매개변수가 없는 생성자)
- 역할이 뭔가? **멤버필드의 값을 초기화시켜준다. 객체생성 이후 처음으로 저장될 값을 대입한다.**
- 초기화를 간단하게 할 때는 처음부터 멤버필드에 값을 대입하면 된다. 그러나 복잡한 처리과정이 필요하다면 생성자를 이용한다.
- 객체를 만들 때 반드시 생성자를 호출하여 만들어진다. 생성자를 호출하고 나면 인스턴스가 만들어진다.
* **생성자의 형태**
    - 클래스, 멤버필드, 멤버메소드, 객체의 형식과 정확히 구분하여 외우자!!
        ```java
	        [접근제한자] 클래스명(매개변수) {
	            //객체를 생성하면서 수행할 작업(코드)
	        }
        ```
    - 메소드와 다른 점은, [반환타입] 과 반환코드(return;)를 작성하지 않는다
    - **생성자의 이름은 클래스명과 같아야 한다.** 상단의 생성자 형태에서, 클래스명이 생성자명이다.
    - **오버로딩 가능**
* **생성자의 역할**
    - 생성될 **객체(인스턴스)의 초기값을 설정**한다
    - 멤버필드가 처음 가져야 할 값을 설정할 때 사용한다
    - 생성자는 객체를 생성할 때 수행된다

#### :bulb: **UML, Unified Modeling Language**
- 통합 모델링 언어(도구)
- 프로그램의 외적(계획, 일정, 목표, 인력), 내적(요구사항에 맞는 기능)인 것들을 "기획단계"에서 수행한다.
- 클래스 종류, 패키지 구분, 메소드 이름 등 '어떻게 만들어야 하는가?'에 대한 답을 하며 구체적인 부분을 "설계단계"에서 수행한다
- 코드로 "구현"을 해서 완성한다
- **기획, 설계, 구현의 모든 사항이 "문서"로 남아야 한다. 이 문서의 작성법이 UML이다.**
- 기획, 설계, 구현으로 이어지는 프로그램 개발 과정에서 발생하는 중간 산출물을 표현하기 위해 만들어진 "표준화"된 모델링 언어
- 프로젝트 참가자들이 의사소통을 원활하게 할 수 있도록 도와준다. UML이 없다면 개인의 방식을 따라 다른 형식으로 일할 것이다
- 우리한테 필요한 UML 산출물
    - **화면정의서**
        - 화면 구현을 위한 설계서
    - **스토리보드, story board**
        - 프로그램 시작~종료까지 페이지 동작과정과 실행되는 기능들 하나하나 말과 그림으로 설명하는 것 
    - **요구사항 명세서, 정의서**
        - 프로그램의 요구사항을 정리한 문서
        - 명세서: 자세히 작성한 것
        - 정의서: 요약작성한것
    - **유스케이스 다이어그램**
        - 요구사항에서 기능들 위주로 표현한 그림
        - 프로그램을 사용할(동작시킬) 행위자(Actor)를 중심으로 기능을 표현한 것
    - **클래스 다이어그램**
        - 클래스의 구조를 표현한 그림
    - **시퀀스 다이어그램**
        - 클래스의 동작(기능)을 표현한 그림
    - **패키지 다이어그램 (필수x)**
        - 프로그램 코드의 패키지를 표현한 그림
    - **ER 다이어그램**
        - DB를 설계한 것
* **클래스 다이어그램**
    - 프로그램을 설계할 때 클래스의 형태, 구조, 클래스들의 관계 등을 그림으로 표현한 것
    - SW의 논리적인 구조를 표현한다. 논리적인 구조 = 클래스의 내부 구조 + 클래스들간의 관계
    - 클래스의 정적인(안 바뀌는) 구조를 표현한다. (동적인 것, 동작을 보여주는 것은 시퀸스 다이어그램에서 한다)
    ```java
        ------------
        ㅣ클래스 명 ㅣ 와 같은 식으로 단계를 나눠서 구현하는 것이다.
        ------------
        ㅣ멤버 필드 ㅣ 클래스 사이의 관계는 여러가지다. 포함, 연관, 참조 등등..
        ------------
        ㅣ멤버메소드ㅣ
        ------------
    ```
* :bulb: **접근제한자 표현 기호**
    ```java
        + : public (초록색)
        # : protected
        ~ : default
        - : private (빨간색)
    ```
    ```java
        ex)	멤버필드 표기 예시 '접근제한자기호' [변수명] : [데이터타입]

            private String name;    ->	- name : String
            public int num;         ->	+ num : int
            double height;          ->	~ height : double

    	ex)	멤버메소드 표기 예시
		
            public String getName() { } ->  + getName() : String
                                        '접근제한자' 메소드명() : 리턴타입

            private double display(int n1, int n2) { }  ->	- display(int, int) : double
                                                    '접근제한자' 메소드명(매개변수의 자료형) : 리턴타입
    ```
* :bulb: **스테레오 타입, Stereo type**
    - 클래스의 특수한 기능을 표현할 때 사용한다
    - <<특수 기능>> 처럼 사용한다.
    ```java
	    ex)
		<<constructor>> = 생성자
		+ Person()

		<<getter>> = getter메소드
		+ getName() : String
    ```

#### :bulb: **상속, Inheritance**
- 코드의 중복이 있으면, 그 **중복을 줄이기 위해** 상속을 쓰려고 한다.
- 중복되는대로 코드를 쓰면, 재사용성과 확장성이 떨어진다.
- 상속을 통해 클래스의 중복되는 코드를 한 번에 관리할 수 있다. 수정시 수정할 코드가 적어진다.
- (클래스명 뒤에) **extends [부모 클래스 이름] {}**
- 메소드를 호출하는 것과 비슷한 것 같지만, 코드를 정의하는 것과 수행하는 것은 다르다.
    - 클래스를 정의하여 클래스 안의 코드를 그대로 붙여넣는 것처럼 가져다 쓰는 것은 "코드를 정의하는 개념인 상속"이고
    - 메소드를 호출하여 메소드 안의 코드를 수행하는 것이 "코드를 수행하는 것"이다.
- **기존의 클래스 코드를 재사용하여 새로운 클래스를 작성**할 수 있게 하는 문법. (필요한 부분을 수정하고, 추가한다)
- 상속을 주는 클래스(부모클래스)의 코드를 변경하면, 상속을 받는 클래스(자식클래스)들도 전부 반영된다
    - 상속을 주는 클래스 : 부모클래스, 수퍼, 상위, Based(기준의)
    - 상속을 받는 클래스 : 자식클래스, 서브, 하위, Derived(유도된, 파생된) -> 클래스들 간의 관계가 형성된다. 추후 다이어그램에 작성.
- **상속의 문법**
```java
    class Parent {
	  int n1;
	  int n2;
	  String name;
	}

	class Child extends Parent {

	}

	-> Child 클래스는 Parent의 모든 멤버를 상속받는다. (멤버필드, 멤버메소드, 생성자)
	-> Child 클래스는 멤버를 작성하지 않아도 Parent의 멤버를 가지고 있는 것처럼 사용할 수 있다
```

#### :bulb: **오버라이딩, Overriding**
- 메소드 재정의, **이전의 것을 무시하고 덮어 씌우는 것**
- 상속받은 메소드를 자식 클래스가 새롭게 재정의하는 것
- **기존의 코드를 덮어씌운다**

#### :bulb: **오버로딩, Overloading**
- 메소드 중복 정의
- 같은 이름의 메소드를 매개변수의 개수 또는 타입, 순서를 다르게 작성하여 **다른 메소드를 추가 정의하는 것**
- **오버로딩 성립 조건**
    1. 메소드 이름이 같을 때 적용된다
	2. 매개변수의 자료형의 종류 또는 개수 또는 순서가 달라야 한다
	3. 리턴데이터타입은 오버로딩과 상관없다

#### :bulb: **바인딩, Binding**
- 메소드의 호출코드(사용)와 메소드의 정의코드(구현)가 연결되는 과정
- **정적 바인딩 : 프로그램 실행 전 바인딩 되는 것**
	- 메소드 호출하는 객체변수의 데이터타입만 보고 바인딩된다.
- **동적 바인딩 : 프로그램 실행 중에 메소드가 호출될 때 바인딩 되는 것**
	- 동적생성된 인스턴스의 데이터타입을 보고 바인딩된다
- 자바는 기본적으로 동적 바인딩을 수행한다. 메소드가 호출될 때 메소드의 정의코드와 연결된다.

#### :bulb: **super 키워드**
- super.
    - 상속받은 부모객체 참조
    - **자식클래스에서 부모클래스의 멤버에 접근할 때 사용한다**
    ```java
        ex) this.num = 10; //자식클래스의 멤버 num
            super.num = 20; //부모클래스의 멤버 num

            //메소드가 오버라이딩 되어있는 상황일 때
            this.display(); //오버라이딩한 메소드
            super.display(); //오버라이딩 전 부모 메소드
    ```
- super()
    - 수퍼 생성자 호출, 부모클래스 생성자 호출
    - 자식클래스의 생성자에서 부모클래스의 생성자를 호출할 때 사용한다
	- 직접 super() 호출 코드를 작성하지 않으면 자동으로 부모클래스의 디폴트 생성자를 호출한다
	- 부모클래스에 매개변수 있는 생성자가 정의되어 있으면 전달인자를 넣어서 호출할 수 있다
    - **자식클래스의 생성자에서 첫번째 코드로 사용해야 한다**

#### :bulb: **final 키워드**
- 더 이상 확장할 수 없도록 설정하는 키워드
- final 키워드의 적용 위치
    - **변수** : 딱 한 번만 초기화(대입)할 수 있도록 설정 변수를 상수화시킨다
    ```java
	    ex) public final int MAX = 5;
		    public static final int LEN = 10;
    ```
    - **메소드** : 더 이상 오버라이딩 할 수 없도록 설정
    ```java
	    ex) public final void out(){
	            //자식클래스에서 재정의(오버라이드) 할 수 없음
		    }
    ```
    - **클래스** : 더 이상 자식클래스를 생성할 수 없도록 설정
    ```java
	    ex) public final class Child() {
		        //상속을 줄 수 없게 된다
		    }
    ```

#### :bulb: **for each 구문**
```java
for( [요소의데이터타입] [변수명] : [배열 or 컬렉션] ) {
    //for구문에 선언된 변수를 사용할 수 있다
}
```
- 배열이나 컬렉션의 모든 요소를 이용한 **반복작업을 쉽게 수행할 수 있도록 만들어진 반복문**
- 배열의 요소를 0번째부터 하나씩 변수에 대입하여 마지막 요소까진 반복한다
```java
ex)
    int[] arr = {1,2,3,4,5};
	
    for( int num : arr ) {
	    //num변수 사용 가능
	    System.out.println( num );
	}

    for(int i=0; i<arr.length; i++) {
	    //arr[i] 사용
    }
```

#### :bulb: **다형성, Polymorphism**
- 한 요소가 다양한 모습으로 표현되거나, 다양한 기능을 수행할 수 있음을 뜻한다
- 부모클래스 타입의 객체변수를 이용하여 다양한 자식클래스 타입을 처리한다. 대입, 메소드호출(동적바인딩) 등
```java
	ex)	Parent P1 = new Child1();
		Parent P2 = new Child2();
		Parent P3 = new Child3();
    ex)	public void out( Parent p ) {

		}
		out( new Child1() );
		out( new Child2() );
```

#### :bulb: **abstract 키워드**
- 추상화 키워드
- 클래스, 메소드에 사용할 수 있다 (추상클래스, 추상메소드)
* :bulb: **추상 메소드**
    - **동작(실행)코드를 구현하지 않고 추상화시킨 메소드**
    - 메소드의 구현부분(method body, 메소드 몸체, {}부분)을 작성하지 않고, 대신 ; 으로 끝낸다
    - 형태
    ```java
        [접근제한자] abstract [리턴타입] [메소드명](매개변수);
    ```
    - 추상메소드는 상속이 가능하다
    - **추상메소드를 멤버로 가지려면 반드시 추상클래스로 지정되어야 한다**
    - 추상메소드를 상속받는 자식클래스는 추상메소드를 처리해야만 한다
        - 방법1. 오버라이딩한다 (추상메소드->일반메소드)
	    - 방법2. 자식클래스를 추상클래스로 지정한다 (abstract class)
* :bulb: **추상 클래스**
    - **실체화(인스턴스화)할 수 없는 클래스**
    - new연산자를 이용하여 객체생성을 할 수 없다
    - 데이터타입으로 사용하여 객체변수를 만들 수는 있다
    - 추상 메소드를 멤버로 가질 수 있다
    - 반드시 추상 메소드를 멤버로 가져야하는 것은 아니다
    - 형태
    ```java
        [접근제한자] abstract class [클래스명] {

        }
    ```

#### :bulb: **인터페이스, Interface**
- 추상메소드와 상수만 멤버로 가지는 일종의 추상 클래스
- 멤버필드(상수)는 자동으로 public static final 키워드가 적용된다
- 멤버필드에 public, static, final 중 무엇이든 없어도 전부 자동 적용됨
- 멤버메소드(추상메소드)는 abstract 키워드가 기본으로 적용된다
- 멤버메소드에 abstract가 없어도 자동 적용됨
- **사용 목적**
    1. 상수들의 모음집 : **상수들만 따로 관리**하기 위해 사용한다
    2. 메소드 개발 가이드 : **개발해야하는 메소드의 형식을 강제할 수 있다**
---