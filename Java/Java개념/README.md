# Java 기초 개념 정리

## 순서
* [준비사항](https://github.com/thdqudgns/TIL-Today-I-Learned/tree/main/Java/Java%EA%B0%9C%EB%85%90#pushpin-%EC%A4%80%EB%B9%84%EC%82%AC%ED%95%AD)
* [기본개념](https://github.com/thdqudgns/TIL-Today-I-Learned/tree/main/Java/Java%EA%B0%9C%EB%85%90#pushpin-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90)
* [Java의 시작](https://github.com/thdqudgns/TIL-Today-I-Learned/tree/main/Java/Java%EA%B0%9C%EB%85%90#pushpin-java%EC%9D%98-%EC%8B%9C%EC%9E%91)

### :pushpin: 준비사항

* :bulb: **자바(Java) 다운로드 받기**
    - Open JDK 1.8 다운로드 받아서 사용함
    - 구글에서 'openjdk github'검색
    - ojdkbuild/ojdkbuild: Community builds using source ... [링크 들어가기](https://github.com/ojdkbuild/ojdkbuild)
    - 하단 쪽에 Downloads for Windows x86_64 섹션 확인
    - 1.8.0_292-1 항목 확인
    - java-1.8.0-openjdk-1.8.0.292-1.b10.ojdkbuild.windows.x86_64.zip 링크 다운
    - 압축 해제
    - 압축 해제한 폴더 이름을 'java-1.8.0-openjdk'로 변경
    - C:\Program Files\ 폴더에 'Java' 폴더 만들기
    - C:\Program Files\Java\ 폴더에 복사한 폴더 붙여넣기

* :bulb: **JDK(Java) 환경변수 설정하기**
    - 시스템 창 열기 (단축키 : Win키 + Pause/Break)
	(내컴퓨터 창에서 '내 PC' 아이콘에 우클릭 '속성' 선택)
    - 왼쪽 메뉴 중에서 '고급 시스템 설정' 클릭 (또는 하단 목록에서 찾으세요)
    - 고급 탭에서 '환경변수' 버튼 클릭
    - '새로 만들기' 버튼 클릭
	변수이름: JAVA_HOME
	변수 값: C:\Program Files\Java\java-1.8.0-openjdk
	입력하고 확인
    - Path 항목 변수를 찾아서 '편집' 버튼 클릭.
	윈10일 경우 '새로 만들기' 클릭하고
		C:\Program Files\Java\java-1.8.0-openjdk\bin 추가
		(찾아보기 버튼누르고 찾아도 됨)

	윈7, 8일 경우 기존내용 절대 지우지 말고 가장 오른쪽 끝에
		;C:\Program Files\Java\java-1.8.0-openjdk\bin 추가
		( ;세미콜론 잘 입력할 것)
    - 확인
    - 확인

* :bulb: **JDK(Java) 설치 확인**
    - Win키 + r (실행창) 열기
    - 'cmd' 입력
    - 검은색 프로그램 창이 뜬다
	java -version 명령어 입력
	javac -version 명령어 입력
	-> 두 명령어의 결과가 모두 같은 버전으로 제대로 출력되어야 설치완료

* :bulb: **콘솔, Console**
    - 시스템과 사용자(유저) 사이의 대화창
    - 해당 시스템에 직접적인 명령을 내릴 수 있는 환경
    - Windows Console, 윈도우 콘솔: 실행 창에서 'cmd'입력하여 실행

* :bulb: **이클립스 툴 다운로드**
    - [링크접속](http://www.eclipse.org/)
    - 화면 우측 상단 Download 버튼 클릭
    - Download x86_64 누르지말고! Download Packages 링크 클릭
    - 우측 중간쯤에 MORE DOWNLOADS 항목 확인
    - Eclipse 2020-06 (4.16) 링크 클릭
    - Eclipse IDE for Java Developers 항목에서 자기 컴퓨터 OS에 맞게 다운로드
    - 압축 해제
    - 해제된 폴더 'eclipse'를 복사하여 적당한 폴더에 붙여넣기 (폴더 이름 변경해도 됨) (원본 eclipse 폴더는 백업용으로 남겨놓고 사용하면 좋음)
    - 폴더 내 eclipse.exe 파일로 실행

* :bulb: **workspace(작업폴더) 지정하기**
    - 내 컴퓨터를 이용해서 D:\workspace\ 폴더 생성. (다른 폴더여도 상관없음) (위치 기억하기 쉬운 폴더로 생성할 것)
    - 이클립스 실행하고 나오는 창(workspace선택창)에서 "Browse..." 버튼 누르도 폴더 선택
    - Launch 클릭
    - workspace를 변경하고 싶다면 이클립스 File메뉴 - Switch Workspace에서 변경


* :bulb: **코딩 폰트 적용하기**
    - [네이버 나눔고딕 코딩글꼴](https://github.com/naver/nanumfont)
    - Ver 2.5 (2016.10.24 배포) 링크 클릭
    - 다운 받은 압축파일 해제 (NanumGothicCoding-2.5.zip)
    - NanumGothicCoding.ttf, NanumGothicCoding-Bold.ttf 파일 두 개 확인
    - 두 파일을 C:\Windows\Fonts\ 폴더에 복사, 붙여넣기

* :bulb: **이클립스 글꼴 바꾸기**
    - Window 메뉴 - Preferences 항목 선택
    - 왼쪽 메뉴 중에서 General - Apperance - Colors and Fonts
    - Text font 검색 ( Basic 항목에 있는 Text Font )
    - 항목을 선택하고 우측에 "Edit..." 버튼 클릭
    - 글꼴을 "나눔고딕코딩"으로 설정

* :bulb: **프로젝트 Import 하는 방법**
    - 이클립스 File 메뉴 - import... 선택
    - General항목에서
    - Existing Projects into Workspace 선택
    - Next
    - Select root directory: 쪽에서 Browse...
    - 자기 workspace 폴더 찾아가기
    - 폴더 선택 버튼 클릭
    - Projects: 항목에서 불러올 프로젝트 체크
    - Finish

* :bulb: **이클립스 자바 프로젝트 만들기**
    - **프로젝트, Project**   
    프로그램 개발하기 위한 환경   
    -> 개발된 소스코드를 관리하는 폴더라고 생각하면 된다
    - File - New - Java Project 선택 - 프로젝트 이름 "Test"로 작성   
    (프로젝트는 첫글자 **대**문자)
    - src폴더 우클릭, New - Package 선택 - "simple" 입력 - Finish   
    (패키지는 첫글자 **소**문자)
    - simple 패키지 우클릭, New - Class 선택 - "Hello" 입력 - Finish   
    (클래스는 첫글자 **대**문자)
    - 기존 코드 그대로 유지하며 아래와 같이 작성
    ```java
    package simple;

    public class Hello {

	    public static void main(String[] args) {
		
		    System.out.println("Hello Java");
	    }
		
    }
    ```
    - 저장 (단축키 ctrl + s)
    - 실행 (단축키 ctrl + F11)
    - 하단 Console뷰(탭)에서 'Hello Java' 문구 출력 확인
---

### :pushpin: 기본 개념

* :bulb: **자바 프로젝트, Java Project**
    - Java 프로그램 개발을 하기 위해 만드는 환경(폴더)
    - 주로 하나의 프로그램을 개발하기 위해 프로젝트 1개를 생성하는 편이다

* :bulb: **패키지, Package**
    - 프로그램을 구성하고 있는 코드들을 모아놓는 폴더(꾸러미)
    - 비슷한 기능이나 하나의 기능을 구현할 때 필요한 소스코드들을 모아놓는다
    - 자바 프로젝트에는 반드시 1개 이상의 패키지로 구성한다

* :bulb: **소스 코드, Source Code**
    - 프로그램을 개발하기 위해 작성된 코드   
	**Source**: 원시의, 원본, 출처   
	**Source Code**: 프로그램의 원본이 되는 코드
    - 자바에서는 클래스(Class) 단위로 소스코드를 작성한다
    - 자바 클래스파일의 확장자는 ".java" 로 가진다

* :bulb: **자바 프로그램 개발(실행) 과정**
    ```java
    소스코드 작성 --컴파일--> 바이트코드  --실행--> JVM
	   .java     --compile--> .class    --run--> JVM
	(Source Code)   ---->   (Byte Code)   ---->  (Java Virtual Machine)
    ```
    - 고급언어(Java코드)를 저급언어(바이트코드)로 번역하는 과정을 컴파일(Compile)이라고 한다
    - 컴파일러(Compiler)가 컴파일을 수행한다
    - 이클립스에서는 소스코드를 저장하면 자동으로 컴파일된다
    - 컴파일이 수행될 땐 소스코드에 대한 문법 검사도 같이 이루어진다. **자바 컴파일러**: javac.exe
    - 프로그램을 실행하면 JVM이 바이트코드를 읽어 실행한다. **실행 프로그램**: java.exe
    - **고급 언어(High Level)** -> **사람**이 이해하기 쉬운 형태의 프로그래밍 언어
    - **저급 언어(Low Level)** -> **컴퓨터**가 이해하기 쉬운 형태의 프로그래밍 언어

* :bulb: **컴파일러, Compiler (compile)**
    - 코드를 실행하기 전에 미리 번역해놓는 방식
    - 사전에 번역하는 시간이 많이 필요하다
    - 실행하는 동안에는 따로 번역할 필요가 없어 빠른 반응성을 보인다

* :bulb: **인터프리터, Interpreter (interpret)**
    - 코드를 미리 번역해놓지 않고 실행할 때 필요한 부분을 번역하여 실행하는 방식
    - 사전 번역 시간이 필요없다, 곧바로 실행 가능
    - 특정 기능을 실행할 때마다 번역할 시간이 필요해서 반응이 느린 편이다

* :bulb: **JIT 컴파일, Just-In-Time Compiler**
    - 인터프리터 기반으로 동작한다
    - 한번 번역한 코드는 캐시(cache, 임시저장소)에 저장해놓고 사용한다
    - 인터프리트의 실행속도(반응성)가 느린 점을 보완한 방식
    - JVM은 JIT컴파일 방식으로 바이트코드를 실행한다

* :bulb: **자료형, Data Type**
    - 데이터를 표현하는 정해진 방식
    - 데이터 표현법(규칙)
    - 프로그램에서 사용하는 데이터를 표현하는 방법이다

* :bulb: **자바의 기본 데이터타입**
    - 자바에서 데이터를 표현하는 8가지 방식
    - 정수형 타입 (소수점 이하를 표현하지 않는 숫자 형식)   
	    1 byte (1Byte) -128 ~ 127   
	    2 short (2Bytes) -32768 ~ 32767   
	    3 **int** (4Bytes) 약 -21억 ~ 약 21억 => **(정수형 기본 데이터타입)**   
	    4 long (8Bytes)	약 -900경 ~ 약 900경
    - 실수형 타입 (소수점 이하를 표현하는 숫자 형식)   
        5 float (4Bytes)   
	    6 **double** (8Bytes) => **(실수형 기본 데이터타입)**
    - 논리형 타입   
	    7 **boolean** (1Byte) true/false => **(논리형 기본 데이터타입)**   
    (true:참, false:거짓)
    - 문자형 타입   
	    8 **char** (2Bytes) => **(문자형 기본 데이터타입)**   
	    - 문자형은 컴퓨터에서 정수형 타입으로 처리된다.
        - 코드화 시킨 문자체계(매핑표)를 적용해서 인식/사용한다.
        - 자바는 유니코드(Unicode)를 사용한다.
	- **ASCII코드 American Standard Code for Information Interchange**   
	    - 영어 대소문자, 숫자, 특수기호, 가상키를 1:1로 매핑(mapping)한 표   
	    - 한글 없음
	- **유니코드 Unicode**   
	    - ASCII로만 표현할 수 없는 전세계 문자를 매핑한 표   
	    - 유니코드는 변환과정(인코딩)을 거쳐 사용한다   
	    - 한글 인코딩 방식은 UTF-8, EUC-KR, CP949(MS949)   
	    - 주로 UTF-8을 사용한다

* :bulb: **데이터 형 변환, Data Type Casting**
    - 데이터의 타입을 일시적으로 다른 타입으로 변환하는 것
    - 연산은 피연산자들의 데이터타입이 같아야 수행 가능하다
    - 서로 다른 데이터타입의 피연산자를 연산하려면 형변환이 필요하다 -> 형변환을 통해 데이터타입을 일치시킨 이후에 연산할 수 있다
    - **자동 형변환(묵시적, 암시적, 암묵적)**
        - 표현범위가 작은 데이터를 큰 데이터로 사용할 때
            ```java
            11 + 34.56	( int + double )
		    -> 11.0 + 34.56	( double + double, 자동 형변환 )
		    -> 45.56	( double )
            ```
    - **강제 형변환(명시적)**
        - 표현범위가 큰 데이터를 작은 데이터로 사용할 때
        - 형변환 연산자를 사용한다
        - 데이터 또는 변수 앞에 (type) 형식으로 적어준다
            ```java
            11 + (int)34.56	( int + (int)double )
		    -> 11 + 34	( int + int )
		    -> 45		( int )
            ```
    - **자바 자료형의 표현범위 비교**
        ```java
        byte < short < int < long < float < double   
		        char < int
        ```
        - boolean은 표현범위를 비교할 수 없음 (형변환 안됨)

* :bulb: **변수, Variables**
    - 변하는 값
    - 데이터(값)를 저장하는 메모리의 공간
    - 데이터를 저장하는 그릇
    - 저장할 수 있는 데이터의 형식을 자료형으로 지정하여 생성한다
    - 변수 공간에는 한 순간에 하나의 데이터만 저장할 수 있다
    - 저장된 데이터는 계속 변경할 수 있다
    - **변수 선언(Declaration)**
        - 프로그램에서 사용하려는 변수를 생성하는 코드
        - 자료형을 명시해서 변수를 선언한다   
    	[자료형] [변수명];   
        ```java
        int num;
        ```
        - 각 자료형에 대입하는 기본값
            - 정수 0
            - 실수 0.0
            - 논리 false
            - 문자 \0 (null문자)
    - **변수 대입(Assignment)**
        - 생성된 변수공간에 데이터를 저장하는 것
        - 자료형에 맞는 데이터를 저장해야한다   
	    [변수명] = [데이터];   
        //오른쪽의 데이터를 왼쪽의 변수공간에 저장한다   
        ```java
        num = 14;
        ```
    - **변수의 선언과 동시에 초기화(Initialization)**
        - 변수를 생성하면서 대입을 한번에 처리하는 것   
    	[자료형] [변수명] = [데이터];   
        ```java
        int data = 555;
        ```
        - 쓰레기값이 변수에 저장되는 것을 방지하고 변수의 값을 초기화한다
        - **쓰레기값, Garbage Value**   
            - 메모리공간은 사용이 끝난 후 별도로 지우지 않는다. 사용이 종료 되어도 이전 데이터흔적이 남아있게 된다.
            - 새로운 변수를 선언하면 메모리의 적당한 공간을 사용하게 되고, 이전 데이터흔적이 남아있을 수 있다.   
             -> 어떤 값이 들어있는 지 알 수 없는 상태   
             -> 자바에서는 쓰레기값을 활용할 수 없도록 에러(Error)로 처리한다
    - **변수 명명 규칙(선언 규칙, 네이밍 규칙)**
        - 영어 대문자, 소문자, 숫자만 허용한다
        - 특수기호는 _ 와 $ 만 허용한다
        - 대소문자를 구분한다 ( A 와 a 다른 이름 )
        - 숫자로 시작하면 안된다
        - 띄어쓰기 금지
        - 변수명과 패키지명과 메소드명은 소문자로 시작한다
        - 클래스명은 대문자로 시작한다

* :bulb: **상수, Constant Number**
    - 변하지 않는 값
    - 데이터의 값 자체를 뜻한다
    - 자료형을 가지고 있음
        ```java
        123	- int형 상수
		12.34	- double형 상수
		'Y'	- char형 상수
		true	- boolean형 상수
	    654L	- long형 상수(정수값 뒤에 L 붙여 사용)
		3.14f	- float형 상수(실수값 뒤에 f 붙여 사용)
        ```
    - **상수의 종류**
        - **리터럴(Literal) 상수** : 상수 그 자체를 뜻한다
        - **이름있는 상수** : 변수를 상수화시켜 사용한다
    	    - 변수를 만들고 값을 변경할 수 없도록 강제한 것
            - final키워드를 적용시켜 사용한다
            - 이름있는 상수의 이름은 모든 글자를 대문자로 작성한다
            - 단어의 구분은 Snake Case로 한다( _ 이용)

* :bulb: **연산, Operation, Operate**
    - 프로그램의 작동
    - 컴퓨터의 모든 작동
    - **연산자, Operator**
        - 연산을 기호로 나타낸 것이다
    - **피연산자, Operand**
        - 연산의 대상(값, 상수, 변수 등)
    - **연산자를 구분하는 기준**
        - 피연산자의 개수
            - 단항연산자, Unary Operator
	        - 이항연산자, Binary Operator
	        - 삼항연산자, Ternary Operator
        - 연산의 기능에 따른 분류
            - 산술 연산자 (+, -, *, /, %)
	        - 관계 연산자 (>, <, >=, <=, ==, ===, !=)
	        - 논리 연산자 (&&, ||, !)
	        - 대입 연산자 (=, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=, >>>=)
	        - 비트 연산자 (<<, >>, >>>, &, |, ^, ~)
	        - 기타 연산자 (참조 . , 형변환 (type), 삼항 (조건식)? (참):(거짓) )

* :bulb: **공백문자, White Space**
    ```java
	SP, SPace
    - 띄어쓰기		' ' (ASCII 32)
	
    LF, Line Feed, New Line
    - 개행, 줄바꿈	'\n' (ASCII 10)
	
    HT, Horizontal Tab
    - 탭, 수평탭	'\t' (ASCII 9)

	** 개행(줄바꿈)은 운영체제에 따라 '\r' 과 '\n'을 조합해서 사용한다
    ('\r' - CR, Carriage Return, '\n' - New Line)
    *Carriage Return: 맨 첫 칸으로 커서를 이동시킨다.
	*New Line: 다음줄로 커서를 이동시킨다.

	윈도우 : '\r''\n' 두 문자를 합쳐서 사용함
	리눅스 : '\n'
	맥OS : '\r' 이었는데 요즘엔 '\n'

    *Form: 종이
	*Feed: 먹이 - 종이를 먹는다. 종이가 타자기 안으로 들어감. Page Down과 같은 것
	*Line Feed: 줄 먹이기, 한 줄을 먹인다.
    ```

* :bulb: **데이터 입출력**
    - **키보드 = 표준입력, Standard Input (Stdin)** -> 키보드가 없으면 컴퓨터가 실행되지 않기도 한다.
    - Java에서는 Stdin을 **System.in** 으로 표현한다. Java에서 키보드의 입력을 받아들이는 API가 System.in이다. 프로그램의 **입력스트림**을 통해서 입력.
    - 입력의 기본이 키보드였다면, 출력의 기본은 모니터다. **모니터 = 표준출력, Standard Output (Stdout)**
    - Java에서는 Stdout을 **System.out** 으로 표현한다. Java에서 모니터로 출력하는 API가 System.out이다. 프로그램의 **출력스트림**을 통해서 출력. (스트림은 SW 프로그램이다)
    - System.in과 System.out을 합쳐 **System.io**라고 부른다.
    - 프로그램 내에서는 빠르게 작동하지만, 스트림을 통해 장치를 오갈 때 장치는 느리게 반응한다. 그래서 입출력은 굉장히 느리다. **이것을 보완하기 위해 임시저장소 Buffer를 만들어 여기에 출력사항을 기록한다.** 그리고 프로그램은 다른 일을 시작한다. 모니터는 Buffer에서 조금씩 가져와 일을 한다. 그러면 **프로그램과 모니터의 작업이 구분된다.** 프로그램은 Buffer에 데이터를 저장시키고 다른 일을 하게 되고, 모니터는 자신의 속도에 맞게 작업을 처리할 수 있다.
    ```java
	키보드 ---(입력스트림)---> 프로그램 ---(출력스트림)---> 모니터
	// 입력스트림, 출력스트림에 Buffer 있다.
    ```
    - 이번엔 입력 Buffer를 생각해보자. 초기 콘솔 입력 창에 "123\n" 을 입력했다고 치자. nextInt는 입력 Buffer 안에 있는 정수를 찾아서 프로그램으로 가져오는 기능을한다. **(123만 가져옴)** 프로그램으로 가져온 데이터는 Buffer에서 지운다.
    - nextLine은 입력 Buffer 안에 있는 개행문자'\n' 전까지의 데이터와 개행문자'\n'을 프로그램으로 가져온다. 그런데 입력 Buffer 안에는 123이 지워지고 현재 **'\n' 밖에 남지 않았다.** 그래서 뭔가를 입력할 새도 없이 **'\n'을 인식하여 바로 다음 출력될 문자열이 출력된다.**
    - 이것을 해결하기 위해서는 **남아있는 '\n'을 지워줘야 한다.** 그래서 중간에 **sc.nextLine();**을 넣어주면 된다. (sc는 변수명) 이것이 남아있는 '\n'을 가져갈 것이다.
    ```java
    ** 버퍼에서 해당 데이터타입의 자료만 가져가는 기능들 (개행문자 \n 은 남긴다)
    next()
    nextInt()
    nextDouble()
    nextBoolean()
    nextByte()
    nextShort()
    nextLong()
    nextFloat()

    ** nextLine()은 문자열을 가져가고 개행문자를 지워준다 

    이런 차이로 버퍼이슈가 생긴다.
    ```
    
    ```java
    Scanner sc = new Scanner(System.in);
    //스캐너 클래스의 객체 sc는 참조형이다.
    ```
    - 변수 sc를 선언하면 변수 공간A가 생성된다. 그 공간A에는 값이 저장되진 않고, 값을 지니고 있는 또 다른 공간B의 **주소**가 있다. 
    - 키보드를 통해 입력된 값이 공간B에 저장된다. 변수를 활용하면 변수에 저장된 **주소**를 읽고, 공간 B에 입력된 값을 가져온다.

* :bulb: **제어문, Control Statement**
    - 프로그램의 기본 진행 흐름(**위->아래**)을 변경(제어)하는 구문
    ```java
	** 프로그램의 기본 진행 : 메인 메소드에서 시작하여 코드를 한 줄씩 순서대로 전부 실행하는 것

	ex)	**프로그램의 메뉴
		
		1. 새로 만들기
		2. 옵션
		3. 끝내기

		선택: _ 
		
		(Java는 클릭이 아니라 명령프롬프트와 같은 콘솔창에서 진행된다)
    ```
    - 조건에 따라 **프로그램의 진행흐름을 바꾸는 것**이 제어문이다. 개발자가 원하는 흐름으로 프로그램을 제어할 수 있게 된다.
    - **제어문의 종류**
        - **조건문, condition** : if, else, else if
        - **반복문, loop** : for, while, do-while
            ```java
            for문에서 조건식을 작성할 때,
            초기식은 0으로 사용하는 것이 일반적이고 
            조건식은 되도록 등호 없이 하는 것이 좋다. 
            (>= or <= 가 아니라 > or <으로)
            ```

            ```java
            for문 중첩으로 별찍기를 해보니, 알게 된 것이 있다. 
            for문의 정수형 변수 i,j을 단순히 행과 열로 보기보다, 
            조건식을 통해 찾아야 하는 반복횟수로 보는 것이다.

            i가 몇일 때 j가 얼만큼 반복되어 가로로 이어지는지, (개행은 ln으로 해결)
            
            - 초기식의 시작은 0으로 설정
            - 조건식의 부등호는 등호가 없이 초과, 미만으로만 설정
            - i의 조건식은 행을 보고 정하고,
            - j의 조건식은 반복 횟수를 보고 정하는 것이다.
            ``` 
        - **선택문, selection (조건문에 포함됨)** : switch
        - **기타 제어문** : break, continue

* :bulb: **배열, array**
    - 같은 자료형의 여러 변수를 하나의 묶음으로 사용하는 것
    - 여러개의 변수를 한 번에 선언(생성)할 수 있다
    - 선언되는 변수들의 이름을 고민하는 노력이 줄어든다
    - 한꺼번에 선언된 변수 공간들을 인덱스(index)를 이용하여 관리한다
    - **배열의 선언 ( arr = 주소공간 )**
        - 배열 공간에 대한 참조값을 저장할 수 있는 변수 선언
        ```java
        데이터타입[] 배열명;
        ex) int[] arr; //추천
            char[] chArr;
            double[] dbArr;

        데이터타입 배열명[];
        ex)	int arr[]; //비추천
            char chArr[];
            double dbArr[];
        ```
    - **배열 생성 ( arr[0] = 데이터공간 )**
        - 실제로 데이터를 저장할 수 있는 변수공간(요소, Element)을 생성한다
        ```java
       	new 데이터타입[개수]

        ex) int[] arr; //배열 변수 선언
            arr = new int[10]; //배열 생성
            
        ** 배열의 크기(길이)(size, length)는 양수로 지정해야만 한다 ">=1"
        음수로하면 에러난다 negative size
        ```
    - **배열의 요소 접근(활용)**
        - 일반 변수처럼 사용하면 되고, index 번호까지 명시해줘야 한다
        - 배열의 인덱스(index)를 이용하여 요소(Element, 구성요소, 저장공간)에 접근한다
        - 인덱스는 0부터 시작하여 1씩 증가한다. (for반복문도 0부터 시작하게 했다. 비슷하다. 그래서 배열과 반복문을 조합해서 사용하는 경우가 많다)
        - 인덱스로 음수를 사용할 수 없다
        - 배열의 크기를 벗어난 인덱스를 사용할 수 없다
        ```java
        ex) new int[10];
		    0~9의 인덱스를 가진다
		    -> 0~'lenght-1' 만큼만 사용가능하다
        ```
* :bulb: **플래그, flag**
    - 깃발이라는 뜻
    - 특정 상황이나 상태 등을 기억하기 위해서 사용한다
    - 다른 프로그램이나 다른 로직에 신호를 보내기(남기기) 위해 사용하는 값(변수)
    - programming에서는 주로 boolean변수를 사용한다 (+ int도 사용한다. 상황이 3가지 보다 많을 때)
    ```java
    ex)	boolean isPositive = false; //플래그
	
		if (num>0) {
		  isPositive = true;
		}

		if(isPositive){
		  System.out.println("양수입니다");
		}else {
		  System.out.println("양수가 아닙니다");
		}
    ```
    - 프로그램의 로직이 끝나는 시점과 결과값이 나오는 시점이 다를 때 사용하면 편하다
    - 로직을 처리하는 도중 결과값이 나오지만, 결과값에 상관없이 끝까지 실행되어야 하는 경우 결과값을 플래그로 저장해 놓는다

---

### :pushpin: Java의 시작

* :bulb: **객체지향 프로그래밍, OOP(Object Oriented Programming)**
    - 객체들을 중심으로 상호작용(데이터 전달, 교환)을 통해 프로그램이 작동되도록 작성하는 프로그래밍 기법
    - 객체마다 **고유의 기능**이 있다. 이 기능은 각각 스스로 활용할 수 있다. 그러나 다른 기능을 이용하려면 통신을 해야 한다
    - **Q: 객체마다 어떤 고유의 기능이 있는가? Q: 그 기능을 어떻게 만드는 것인가?**
    - 객체는 '같은 기능을 가진 집합체'라고 말할 수 있다.
    - 객체의 큰 목적 중의 하나가 '현실세계를 반영'하자는 것이다.
    - 프로그램 코드를 일부 명령어들의 나열로 보지 말고, 명령어들의 **집합체**(=객체)를 중심으로 생각하자. 작게 보지 말고 크게 묶어서 보자.
    - Why? 절차지향프로그래밍(Procedural Programming) : 이것은 코드가 순차적으로 실행된다. **순차적으로 실행될 때의 단점**은 무엇일까? 만약에 코드의 밑에서 **이전에 실행했던 기능을 사용한다면 코드의 위로 올라갔다가 다시 밑으로 내려오거나, 이전의 코드를 현 위치에서 그대로 다시 써내려가야 한다.** 이런 복잡함을 해결하기 위해 **기능이 있는 코드를 처음부터 따로 생성하여, 불러오는 방식**이 객체지향 프로그래밍이다.
    * :bulb: **객체, Object**
        - 현실 세계에 존재하는 모든 것들.
        - 프로그램에서 구현(표현)하고자 하는 모든 대상. 이것을 객체라고 본다
    * :bulb: **클래스, Class**
        - 객체를 만들기 위해서 코드로 작성한 것
        - 객체(현실대상을)를 추상화한 것
        ```java
    	[접근제한자] [클래스식별자] class [클래스명] {
		    //멤버 필드
		    //멤버 메소드
	    }
        ``` 
    * :bulb: **추상화, Abstraction**
        - **수많은 데이터 중에서 필요한 데이터만 선별한 것**
        ```java
        ex)
        프로그램 목표 : 주소록(이름, 전화번호, 주소)
        
        객체(현실세계 대상)
        -> 사람의 데이터
            이름 *
            나이
            출생지
            주민번호
            전화번호 *
            주소 *
            학력
            친구목록
            ...
            
        수많은 데이터들이 있어도 필요한 것은 소수다.

        전체 데이터 중에서 필요없는 데이터는 버리고
        필요한 것만 선택해오는 것을 "추상화"라고 한다
        ```
         - 객체에는 너무 많은 정보가 있다. 필요없는 정보도 있다. 여기서 필요한 데이터만 뽑아서(추상화해서) 클래스를 만드는 것이다.
        ```java
                                            (인스턴스화)
                        (추상화)             (객체 생성)
        현실 세계 대상 -------------> 클래스 -------------> 객체, Object
        (객체, Object)               (class)                (Instance)
                                                            메모리에 저장된 정보를 의미
        ```
        - 현실의 정보(객체)를 필요한 것만 코드로 작성(클래스)하여 프로그램 안에 저장(인스턴스)시킨다
        - class의 이름은 그 정보의 주제로 한다
        - 프로그램으로 아직 만들지 않은 정보도 '객체'라 부르고, 프로그램으로 만든 것도 '객체'라고 부른다. 그러나 프로그램 안의 객체는 '인스턴스'라고도 부른다.
        - (현실세계대상)객체의 공통적인 속성, 기능, 행위 등을 개념화하는 작업
        - 프로그램에서 필요한 요소들만 집중해서 정리해야 한다. 프로그램에서 필요로 하지 않거나 중요하지 않은 요소는 무시한다
    * :bulb: **인스턴스, Instance**
        - 메모리에 생성된 객체
        - 클래스(class) 코드를 통해서 생성된 실체(객체)
        - "new"가 메모리에 인스턴스 공간을 생성하는 코드다. 그러면 이제 변수가 이 공간을 참조하는 것이다
    * :bulb: **인스턴스화, Instantiate**
        - 인스턴스로 만드는 것
        - 메모리에 실제화하는 작업
        - 메모리 공간을 차지하게끔 생성하는 것
        ```java
            **클래스 ----->	인스턴스(객체)
            (코드덩어리)    (메모리를 차지하는 실제 공간)
            (자료형)	    (변수)
            (건축설계도)	(건물)
        ```
    * :bulb: **접근제한자, Access Modifier**
        - **private, default(package), protected, public**
        - 사용 목적: 객체에서 클래스로 정보가 이동할 때 추상화가 있었다. 그래서 꼭 있어야 하는 정보만 클래스에 있다. 그래서 클래스에 있는 정보는 중요하게 다뤄진다. 클래스에 있는 '멤버필드'와 '멤버메소드'는 중요하다. 지워지면 안되니까 안전하게 보관하려고 했다.
        - 그런데 이를 일반 변수로 설정하면 누구나 접근이 가능하니까 보안을 높여서 접근을 제한 하려고 한다. 그래서 접근제한자를 만들었다. 클래스의 정보를 보호하기 위해.
        - 객체의 멤버필드(고유한 속성), 멤버메소드(고유한 동작과 기능)에 대한 정보를 객체 외부에 함부로 공개하지 않기 위해 사용한다. (이런 여러 개념들의 사용목적을 알면 활용도가 높아지고, 면접 때도 물어본다)
        - 객체는 추상화 이후의 결과물이 된다. -> 프로그램에서 중요한 정보만 추출한 것
        - 객체의 멤버를 외부에서 함부로 접근하면 프로그램에 악영향을 끼칠 수 있다. 그래서 안전하게 써야 한다. 외부 접근을 차단하려고 한다. -> 모두 막는 건 아님. 일부는 열고 일부는 닫는다.
	    - 필요한 정도까지만 멤버를 공개하고, 나머지는 제한한다.
        - **접근제한자의 종류**
            - 종류에 따라 정보를 공개하는 정도가 달라진다
            - **private** : 해당 클래스 내부에서만 접근 가능. 바깥쪽에서는 뭐가 있는지도 모른다.
            - **default** : 같은 패키지의 다른 클래스까지 접근 가능. 같은 패키지의 클래스들끼리 상호작용하게 함. 같은 기능, 같은 목적을 지닌 클래스들끼리 한 패키지에 묶음. (키워드 X, 변수 앞에 아무것도 안 적으면 적용된다)
            - **protected** : 같은 패키지 + 상속 관계의 객체까지 접근 가능. 다른 패키지라도 상속 관계면 접근 가능하다
            - **public** : 모든 접근 허용
        - **공개범위**
        **private < default < protected < public**
        - **접근제한자를 적용할 수 있는 위치**
            - **멤버 필드** : 4가지 전부 적용가능 (주로 private을 적용)
            - **멤버 메소드** : 4가지 전부 적용가능 (주로 public을 적용)
            - **클래스 정의코드** : public 또는 default
    * :bulb: **메소드, Method** = 객체의 기능
        - 함수, function <- 객체의 의미보다 포괄적이다. 자바는 객체로 구성되어 있기 때문에 특정 기능을 객체라고 부르는 것이 함수보다는 어울린다. 그러나 '기능'을 하는 것은 같기에, 큰 차이는 없다.
        - 클래스(객체)의 기능, 동작, 행위 등을 정의하는 코드
        - 메소드를 사용하려면 객체 변수를 통해서 호출하여 사용해야 한다
        - 객체들 간의 데이터 전달 수단(상호작용)으로 사용된다
        메소드의 정의 방법
        ```java
            [접근제한자] [리턴타입] [메소드명] ( 매개변수 ){
            (*주로 public)         (*소문자 시작)
                //실행 코드	        
            }
        ```
        - 자바의 메소드를 호출할 때 전달인자로 절대! 변수공간을 전달하지 않는다.    
            - 변수에 저장되어 있는 '값'만을 복사하여 전달한다
	        - 전달되는 값의 자료형은 참조형일 수도 있고 기본형일 수도 있다.
        - **Call By Value, 값에 의한 호출**
        메소드 호출시, 전달되는 인자의 값이 **기본형 데이터**일 때
        - **Call By Reference, 참조에 의한 호출**
        메소드 호출시, 전달되는 인자의 값이 **참조형 데이터**일 때
        - Call By Value 상황에서는 ()매개변수의 값을 변경해도 **원본(메인메소드의 변수)은 그대로 유지**된다. Call By Reference 상황에서는 매개변수를 통해서 참조한 공간의 값을 변경하면 **원본에서도 변경된 데이터**를 확인할 수 있다. -> 참조값만 복사되는 얕은복사(Shallow Copy)가 된 상황이다.
        - **메소드에서 return코드의 역할**
            1. 반환값 지정하기
	        2. 메소드 종료하기
        - 반환 데이터타입이 void일 경우 반환값을 지정할 수 없다.
		    - return; 코드만 사용할 수 있다.
		    - 반환값 없이 메소드 종료시키는 역할만 수행할 수 있다.
        - 우리가 계속 쓰는 'main()메소드'의 반환타입이 void이므로 return; 코드 사용이 가능하다.
    * :bulb: **클래스, class**
        - **클래스의 접근제한자**
            - public 또는 default(안 붙이는 것)
	        - public 접근제한자 적용 : **어디에서든지 사용**할 수 있는 클래스가 된다. '.java' 파일 안에는 딱 하나의 클래스만 public을 붙일 수 있다. '.java' 파일의 이름과 클래스명이 같아야 한다. -> public클래스는 해당 '.java'파일의 주된 클래스가 된다.
            - default 접근제한자 적용 : **같은 패키지에서만 사용**할 수 있는 클래스가 된다. public클래스의 보조기능을 담당하는 클래스를 만들 때 사용한다. 요즘에는 default클래스를 안쓴다. 보조기능도 그냥 public으로 만들고 패키지로 묶는다. 클래스를 엄청 많이 만든다. 5~60개.
        - **클래스 식별자(제한자, modifier)**
            - 클래스의 용도에 따라서 특별 기능을 부여할 때 사용한다.
            - abstract, final, static 등등...
        - **클래스명**
            - 첫 글자를 대문자로 시작
        - **멤버 필드 (클래스를 사용하는 이유1)**
            - 클래스 코드를 구성하는 변수, 상수 (but, 주로 변수)
            - 설계도. 실제 공간이 만들어지는 시기는 인스턴스화 할 때이다.
            - 객체가 생성될 때, 각각의 인스턴스(객체)마다 변수공간을 만들어 준다. 이때 변수가 된다!
        - **멤버 메소드 (클래스를 사용하는 이유2)**
            - 객체의 기능, 행위를 정의한 코드
    * :bulb: **객체변수**
        - 선언
        ```java
        [클래스명] [객체변수명];
	    ex) Test t1;
        ```
        - 생성
        ```java
        [객체변수] = new [클래스명]();
	    ex) t1 = Test();
        ```
        - 객체의 멤버에 접근
        ```java
        [객체변수].[멤버필드];
	    [객체변수].[멤버메소드]();
	    ex) t1.num = 100;
		    t1.print();
        ```
        '.' 참조연산자를 이용하여 멤버에 접근한다
    * :bulb: **캡슐화, Encapsulation** <- 클래스의 큰 특징
        - 객체지향프로그래밍의 특징 중 하나. 클래스를 캡슐화해서 만든다.
        - **객체의 속성과(멤버필드) 기능(멤버메소드)을 하나의 클래스로 묶어 표현한다.** -> 추상화
        - 프로그램에 필요하고 중요하고 서로 연관 있는 데이터와 기능들을 추출해서 하나의 클래스에 모아놓는다 = 추상화 + 캡슐화 (꼭 하나의 클래스에 작성하는 것은 아니다. 여러 클래스일 수도 있다)
        - 객체를 표현하는 정보(데이터, 멤버필드)와 정보들을 다루는 기능(멤버 메소드)를 같은 클래스로 묶어서 정의한다.
        - 속성(필드)는 중요한 정보이므로 외부에 함부로 공개하지 않도록 처리한다
	        - 정보은닉, Information hiding
	        - 필드에 접근제한자를 적용하여 처리한다
            - 캡슐화 개념 안에 정보은닉이 있다
        - **멤버필드는 private을 적용한다**
        - **멤버메소드는 public을 적용한다** - getter, setter 메소드로 private로 은닉된 필드에 접근한다
    * :bulb: **Getter Method**
        - 멤버필드의 값을 "가져올" 수 있도록 작성한 메소드
        - 작성할 때 규칙: 메소드의 이름을 반드시 "get"으로 시작하고, 멤버필드명 첫 글자만 대문자로 바꿔서 사용한다
        - 형식	
	    ```java
        public [필드의 자료형(리턴타입)] getXxxx(){
	        return [필드명];
	    }

        ex) private int num; 
        //추상화를 거친 중요한 정보이기에 접근제한자 private로 은닉된 멤버필드

	    public int getNum() { 
            //1.멤버메소드라서 public으로 시작
            //2. 필드의 자료형이 int형이라서 그대로 따라 씀. 
            //3. getter메소드를 이용하려고 하기에 이름 명명 규칙 따라서 getNum()으로 작성
	        return num; //가져오자! private로 은닉된 num을!
	    }
        ```
    * :bulb: **Setter Method**
        - 멤버필드의 값을 "저장"할 수 있도록 만든 메소드
        - 메소드명을 "set"으로 시작하고, 멤버필드명 첫 글자만 대문자로 바꿔서 사용한다.
        - 형식
        ```java
        public void setXxxx([필드의 자료형] [필드명]) {
            this.[필드명] = [필드명];
        }

        ex)	private int num; 
        //추상화를 거친 중요한 정보이기에 접근제한자 private로 은닉된 멤버필드

        public void setNum(int num) {
            //1.멤버메소드라서 public으로 시작
            //2. 그 다음에 void를 쓰는 것이 기본
            //3. setter메소드를 이용하려고 하기에 이름 명명 규칙 따라서 setNum()으로 작성
            //4. 형식을 따라 자료형과 변수명을 쓴다
            this.num = num; //여기 클래스에 있는 private로 은닉된 멤버필드 num을 저장하겠다!
        }
        ```
        - **this 키워드(자기 참조 객체)**
            - 클래스를 정의하는 코드에서 클래스 자기 자신을 나타낼 때 사용한다. 'this.'을 이용하여 자신의 멤버필드, 멤버 메소드를 지칭할 수 있다.
        - Source 메뉴를 팝업으로 띄우는 단축키 : alt + shift + s
        - getter, setter 띄우는 단축키 : alt + shift + s 후 r
    * :bulb: **클래스에서 사용되는 변수의 유형**
        - **인스턴스 변수, Instance Variable (파란색 글자)**
            - 일반적인 '멤버 필드'에 의해서 만들어진 변수.
            - 객체 생성(인스턴스화)하면 각 인스턴스마다 변수공간을 따로 가진다
        - ***클래스 변수, Class Variable (기울인 파란색 글자)***
            - static키워드를 적용한 '멤버필드'에 의해서 만들어진 변수. 
            - 클래스변수의 변수공간은 클래스당 단 "한 개"만 만들어진다. (인스턴스마다 만들어지지 않는다) 
            - 프로그램이 동작하기 전에 미리 클래스 영역에 생성한다
            - 같은 클래스타입으로 만든 객체들이 모두 같은 하나의 공간을 공유한다
            - 접근할 때 [클래스명.클래스변수] 형식을 사용한다 = static way
            - (우리의 개발과정에서는 클래스변수를 거의 사용하지 않을 것이다 그러나 API에서는 많이 제공된다)
        - **지역 변수, Local Variable (갈색 글자)**
            - 메소드 내에서 선언된 변수 = 메소드명(){ } 에서 { }안에서 선언된 변수
		    - 그동안 main 메소드 안에서 변수를 선언하고 생성한 것이 이것이다
            ```java
            매개변수도 지역변수로 취급한다.

            접근제한자를 적용할 수 없다. 숨기고 말고 그럴게 없다.
            어차피 밖에서 사용할 수 없다.
            그러나 매개변수를 통해 return하여 
            값만 이동시킬 수는 있다

            메소드가 호출될 때마다 각자의 공간을 생성하고 
            그 안에 지역변수를 저장한다
            (Stack Memory 영역)

            초기화하지 않으면 쓰레기값을 가지게 된다
            ```
    * :bulb: **static 키워드**
        - 클래스의 멤버를 객체 생성없이 사용할 수 있게 해주는 키워드
        - 멤버 필드, 멤버 메소드 모두 적용할 수 있다
        - 인스턴스와는 무관하게 사용할 수 있다
        - 클래스단위로 제어한다
        - 정적인 시점에 사용 준비가 완료된다
        ** 정적인 시점 : 프로그램 동작을 준비하는 시점, 코드 실행 전
        - 정적 멤버필드 : 클래스 영역에 변수공간을 생성한다
        - 정적 멤버메소드 : 곧바로 실행 가능하도록 모든 준비를 마친다
        - 특이사항
            - 정적(static)메소드에서 인스턴스변수 사용 불가
            - 정적(static)메소드에서 정적 변수만 사용 가능
            - 일반 메소드에서 인스턴스변수, 정적(static)변수 둘 다 사용 가능

// 인강 12일차부터 ㄱㄱ