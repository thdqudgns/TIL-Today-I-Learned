# Java 기초 개념 정리

## 순서
* [준비사항](https://github.com/thdqudgns/TIL-Today-I-Learned/tree/main/Java/Java%EA%B0%9C%EB%85%90#pushpin-%EC%A4%80%EB%B9%84%EC%82%AC%ED%95%AD)
* [기본개념](https://github.com/thdqudgns/TIL-Today-I-Learned/tree/main/Java/Java%EA%B0%9C%EB%85%90#pushpin-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90)
* [Java의 시작](https://github.com/thdqudgns/TIL-Today-I-Learned/tree/main/Java/Java%EA%B0%9C%EB%85%90#pushpin-java%EC%9D%98-%EC%8B%9C%EC%9E%91)

### :pushpin: 준비사항

* :bulb: **자바(Java) 다운로드 받기**
    - Open JDK 1.8 다운로드 받아서 사용함
    - 구글에서 'openjdk github'검색
    - ojdkbuild/ojdkbuild: Community builds using source ... [링크 들어가기](https://github.com/ojdkbuild/ojdkbuild)
    - 하단 쪽에 Downloads for Windows x86_64 섹션 확인
    - 1.8.0_292-1 항목 확인
    - java-1.8.0-openjdk-1.8.0.292-1.b10.ojdkbuild.windows.x86_64.zip 링크 다운
    - 압축 해제
    - 압축 해제한 폴더 이름을 'java-1.8.0-openjdk'로 변경
    - C:\Program Files\ 폴더에 'Java' 폴더 만들기
    - C:\Program Files\Java\ 폴더에 복사한 폴더 붙여넣기

* :bulb: **JDK(Java) 환경변수 설정하기**
    - 시스템 창 열기 (단축키 : Win키 + Pause/Break)
	(내컴퓨터 창에서 '내 PC' 아이콘에 우클릭 '속성' 선택)
    - 왼쪽 메뉴 중에서 '고급 시스템 설정' 클릭 (또는 하단 목록에서 찾으세요)
    - 고급 탭에서 '환경변수' 버튼 클릭
    - '새로 만들기' 버튼 클릭
	변수이름: JAVA_HOME
	변수 값: C:\Program Files\Java\java-1.8.0-openjdk
	입력하고 확인
    - Path 항목 변수를 찾아서 '편집' 버튼 클릭.
	윈10일 경우 '새로 만들기' 클릭하고
		C:\Program Files\Java\java-1.8.0-openjdk\bin 추가
		(찾아보기 버튼누르고 찾아도 됨)

	윈7, 8일 경우 기존내용 절대 지우지 말고 가장 오른쪽 끝에
		;C:\Program Files\Java\java-1.8.0-openjdk\bin 추가
		( ;세미콜론 잘 입력할 것)
    - 확인
    - 확인

* :bulb: **JDK(Java) 설치 확인**
    - Win키 + r (실행창) 열기
    - 'cmd' 입력
    - 검은색 프로그램 창이 뜬다
	java -version 명령어 입력
	javac -version 명령어 입력
	-> 두 명령어의 결과가 모두 같은 버전으로 제대로 출력되어야 설치완료

* :bulb: **콘솔, Console**
    - 시스템과 사용자(유저) 사이의 대화창
    - 해당 시스템에 직접적인 명령을 내릴 수 있는 환경
    - Windows Console, 윈도우 콘솔: 실행 창에서 'cmd'입력하여 실행

* :bulb: **이클립스 툴 다운로드**
    - [링크접속](http://www.eclipse.org/)
    - 화면 우측 상단 Download 버튼 클릭
    - Download x86_64 누르지말고! Download Packages 링크 클릭
    - 우측 중간쯤에 MORE DOWNLOADS 항목 확인
    - Eclipse 2020-06 (4.16) 링크 클릭
    - Eclipse IDE for Java Developers 항목에서 자기 컴퓨터 OS에 맞게 다운로드
    - 압축 해제
    - 해제된 폴더 'eclipse'를 복사하여 적당한 폴더에 붙여넣기 (폴더 이름 변경해도 됨) (원본 eclipse 폴더는 백업용으로 남겨놓고 사용하면 좋음)
    - 폴더 내 eclipse.exe 파일로 실행

* :bulb: **workspace(작업폴더) 지정하기**
    - 내 컴퓨터를 이용해서 D:\workspace\ 폴더 생성. (다른 폴더여도 상관없음) (위치 기억하기 쉬운 폴더로 생성할 것)
    - 이클립스 실행하고 나오는 창(workspace선택창)에서 "Browse..." 버튼 누르도 폴더 선택
    - Launch 클릭
    - workspace를 변경하고 싶다면 이클립스 File메뉴 - Switch Workspace에서 변경


* :bulb: **코딩 폰트 적용하기**
    - [네이버 나눔고딕 코딩글꼴](https://github.com/naver/nanumfont)
    - Ver 2.5 (2016.10.24 배포) 링크 클릭
    - 다운 받은 압축파일 해제 (NanumGothicCoding-2.5.zip)
    - NanumGothicCoding.ttf, NanumGothicCoding-Bold.ttf 파일 두 개 확인
    - 두 파일을 C:\Windows\Fonts\ 폴더에 복사, 붙여넣기

* :bulb: **이클립스 글꼴 바꾸기**
    - Window 메뉴 - Preferences 항목 선택
    - 왼쪽 메뉴 중에서 General - Apperance - Colors and Fonts
    - Text font 검색 ( Basic 항목에 있는 Text Font )
    - 항목을 선택하고 우측에 "Edit..." 버튼 클릭
    - 글꼴을 "나눔고딕코딩"으로 설정

* :bulb: **프로젝트 Import 하는 방법**
    - 이클립스 File 메뉴 - import... 선택
    - General항목에서
    - Existing Projects into Workspace 선택
    - Next
    - Select root directory: 쪽에서 Browse...
    - 자기 workspace 폴더 찾아가기
    - 폴더 선택 버튼 클릭
    - Projects: 항목에서 불러올 프로젝트 체크
    - Finish

* :bulb: **이클립스 자바 프로젝트 만들기**
    - **프로젝트, Project**   
    프로그램 개발하기 위한 환경   
    -> 개발된 소스코드를 관리하는 폴더라고 생각하면 된다
    - File - New - Java Project 선택 - 프로젝트 이름 "Test"로 작성   
    (프로젝트는 첫글자 **대**문자)
    - src폴더 우클릭, New - Package 선택 - "simple" 입력 - Finish   
    (패키지는 첫글자 **소**문자)
    - simple 패키지 우클릭, New - Class 선택 - "Hello" 입력 - Finish   
    (클래스는 첫글자 **대**문자)
    - 기존 코드 그대로 유지하며 아래와 같이 작성
    ```java
    package simple;

    public class Hello {

	    public static void main(String[] args) {
		
		    System.out.println("Hello Java");
	    }
		
    }
    ```
    - 저장 (단축키 ctrl + s)
    - 실행 (단축키 ctrl + F11)
    - 하단 Console뷰(탭)에서 'Hello Java' 문구 출력 확인
---

### :pushpin: 기본 개념

* :bulb: **자바 프로젝트, Java Project**
    - Java 프로그램 개발을 하기 위해 만드는 환경(폴더)
    - 주로 하나의 프로그램을 개발하기 위해 프로젝트 1개를 생성하는 편이다

* :bulb: **패키지, Package**
    - 프로그램을 구성하고 있는 코드들을 모아놓는 폴더(꾸러미)
    - 비슷한 기능이나 하나의 기능을 구현할 때 필요한 소스코드들을 모아놓는다
    - 자바 프로젝트에는 반드시 1개 이상의 패키지로 구성한다

* :bulb: **소스 코드, Source Code**
    - 프로그램을 개발하기 위해 작성된 코드   
	**Source**: 원시의, 원본, 출처   
	**Source Code**: 프로그램의 원본이 되는 코드
    - 자바에서는 클래스(Class) 단위로 소스코드를 작성한다
    - 자바 클래스파일의 확장자는 ".java" 로 가진다

* :bulb: **자바 프로그램 개발(실행) 과정**
    ```java
    소스코드 작성 --컴파일--> 바이트코드  --실행--> JVM
	   .java     --compile--> .class    --run--> JVM
	(Source Code)   ---->   (Byte Code)   ---->  (Java Virtual Machine)
    ```
    - 고급언어(Java코드)를 저급언어(바이트코드)로 번역하는 과정을 컴파일(Compile)이라고 한다
    - 컴파일러(Compiler)가 컴파일을 수행한다
    - 이클립스에서는 소스코드를 저장하면 자동으로 컴파일된다
    - 컴파일이 수행될 땐 소스코드에 대한 문법 검사도 같이 이루어진다. **자바 컴파일러**: javac.exe
    - 프로그램을 실행하면 JVM이 바이트코드를 읽어 실행한다. **실행 프로그램**: java.exe
    - **고급 언어(High Level)** -> **사람**이 이해하기 쉬운 형태의 프로그래밍 언어
    - **저급 언어(Low Level)** -> **컴퓨터**가 이해하기 쉬운 형태의 프로그래밍 언어

* :bulb: **컴파일러, Compiler (compile)**
    - 코드를 실행하기 전에 미리 번역해놓는 방식
    - 사전에 번역하는 시간이 많이 필요하다
    - 실행하는 동안에는 따로 번역할 필요가 없어 빠른 반응성을 보인다

* :bulb: **인터프리터, Interpreter (interpret)**
    - 코드를 미리 번역해놓지 않고 실행할 때 필요한 부분을 번역하여 실행하는 방식
    - 사전 번역 시간이 필요없다, 곧바로 실행 가능
    - 특정 기능을 실행할 때마다 번역할 시간이 필요해서 반응이 느린 편이다

* :bulb: **JIT 컴파일, Just-In-Time Compiler**
    - 인터프리터 기반으로 동작한다
    - 한번 번역한 코드는 캐시(cache, 임시저장소)에 저장해놓고 사용한다
    - 인터프리트의 실행속도(반응성)가 느린 점을 보완한 방식
    - JVM은 JIT컴파일 방식으로 바이트코드를 실행한다

* :bulb: **자료형, Data Type**
    - 데이터를 표현하는 정해진 방식
    - 데이터 표현법(규칙)
    - 프로그램에서 사용하는 데이터를 표현하는 방법이다

* :bulb: **자바의 기본 데이터타입**
    - 자바에서 데이터를 표현하는 8가지 방식
    - 정수형 타입 (소수점 이하를 표현하지 않는 숫자 형식)   
	    1 byte (1Byte) -128 ~ 127   
	    2 short (2Bytes) -32768 ~ 32767   
	    3 **int** (4Bytes) 약 -21억 ~ 약 21억 => **(정수형 기본 데이터타입)**   
	    4 long (8Bytes)	약 -900경 ~ 약 900경
    - 실수형 타입 (소수점 이하를 표현하는 숫자 형식)   
        5 float (4Bytes)   
	    6 **double** (8Bytes) => **(실수형 기본 데이터타입)**
    - 논리형 타입   
	    7 **boolean** (1Byte) true/false => **(논리형 기본 데이터타입)**   
    (true:참, false:거짓)
    - 문자형 타입   
	    8 **char** (2Bytes) => **(문자형 기본 데이터타입)**   
	    - 문자형은 컴퓨터에서 정수형 타입으로 처리된다.
        - 코드화 시킨 문자체계(매핑표)를 적용해서 인식/사용한다.
        - 자바는 유니코드(Unicode)를 사용한다.
	- **ASCII코드 American Standard Code for Information Interchange**   
	    - 영어 대소문자, 숫자, 특수기호, 가상키를 1:1로 매핑(mapping)한 표   
	    - 한글 없음
	- **유니코드 Unicode**   
	    - ASCII로만 표현할 수 없는 전세계 문자를 매핑한 표   
	    - 유니코드는 변환과정(인코딩)을 거쳐 사용한다   
	    - 한글 인코딩 방식은 UTF-8, EUC-KR, CP949(MS949)   
	    - 주로 UTF-8을 사용한다

* :bulb: **데이터 형 변환, Data Type Casting**
    - 데이터의 타입을 일시적으로 다른 타입으로 변환하는 것
    - 연산은 피연산자들의 데이터타입이 같아야 수행 가능하다
    - 서로 다른 데이터타입의 피연산자를 연산하려면 형변환이 필요하다 -> 형변환을 통해 데이터타입을 일치시킨 이후에 연산할 수 있다
    - **자동 형변환(묵시적, 암시적, 암묵적)**
        - 표현범위가 작은 데이터를 큰 데이터로 사용할 때
            ```java
            11 + 34.56	( int + double )
		    -> 11.0 + 34.56	( double + double, 자동 형변환 )
		    -> 45.56	( double )
            ```
    - **강제 형변환(명시적)**
        - 표현범위가 큰 데이터를 작은 데이터로 사용할 때
        - 형변환 연산자를 사용한다
        - 데이터 또는 변수 앞에 (type) 형식으로 적어준다
            ```java
            11 + (int)34.56	( int + (int)double )
		    -> 11 + 34	( int + int )
		    -> 45		( int )
            ```
    - **자바 자료형의 표현범위 비교**
        ```java
        byte < short < int < long < float < double   
		        char < int
        ```
        - boolean은 표현범위를 비교할 수 없음 (형변환 안됨)

* :bulb: **변수, Variables**
    - 변하는 값
    - 데이터(값)를 저장하는 메모리의 공간
    - 데이터를 저장하는 그릇
    - 저장할 수 있는 데이터의 형식을 자료형으로 지정하여 생성한다
    - 변수 공간에는 한 순간에 하나의 데이터만 저장할 수 있다
    - 저장된 데이터는 계속 변경할 수 있다
    - **변수 선언(Declaration)**
        - 프로그램에서 사용하려는 변수를 생성하는 코드
        - 자료형을 명시해서 변수를 선언한다   
    	[자료형] [변수명];   
        ```java
        int num;
        ```
        - 각 자료형에 대입하는 기본값
            - 정수 0
            - 실수 0.0
            - 논리 false
            - 문자 \0 (null문자)
    - **변수 대입(Assignment)**
        - 생성된 변수공간에 데이터를 저장하는 것
        - 자료형에 맞는 데이터를 저장해야한다   
	    [변수명] = [데이터];   
        //오른쪽의 데이터를 왼쪽의 변수공간에 저장한다   
        ```java
        num = 14;
        ```
    - **변수의 선언과 동시에 초기화(Initialization)**
        - 변수를 생성하면서 대입을 한번에 처리하는 것   
    	[자료형] [변수명] = [데이터];   
        ```java
        int data = 555;
        ```
        - 쓰레기값이 변수에 저장되는 것을 방지하고 변수의 값을 초기화한다
        - **쓰레기값, Garbage Value**   
            - 메모리공간은 사용이 끝난 후 별도로 지우지 않는다. 사용이 종료 되어도 이전 데이터흔적이 남아있게 된다.
            - 새로운 변수를 선언하면 메모리의 적당한 공간을 사용하게 되고, 이전 데이터흔적이 남아있을 수 있다.   
             -> 어떤 값이 들어있는 지 알 수 없는 상태   
             -> 자바에서는 쓰레기값을 활용할 수 없도록 에러(Error)로 처리한다
    - **변수 명명 규칙(선언 규칙, 네이밍 규칙)**
        - 영어 대문자, 소문자, 숫자만 허용한다
        - 특수기호는 _ 와 $ 만 허용한다
        - 대소문자를 구분한다 ( A 와 a 다른 이름 )
        - 숫자로 시작하면 안된다
        - 띄어쓰기 금지
        - 변수명과 패키지명과 메소드명은 소문자로 시작한다
        - 클래스명은 대문자로 시작한다

* :bulb: **상수, Constant Number**
    - 변하지 않는 값
    - 데이터의 값 자체를 뜻한다
    - 자료형을 가지고 있음
        ```java
        123	- int형 상수
		12.34	- double형 상수
		'Y'	- char형 상수
		true	- boolean형 상수
	    654L	- long형 상수(정수값 뒤에 L 붙여 사용)
		3.14f	- float형 상수(실수값 뒤에 f 붙여 사용)
        ```
    - **상수의 종류**
        - **리터럴(Literal) 상수** : 상수 그 자체를 뜻한다
        - **이름있는 상수** : 변수를 상수화시켜 사용한다
    	    - 변수를 만들고 값을 변경할 수 없도록 강제한 것
            - final키워드를 적용시켜 사용한다
            - 이름있는 상수의 이름은 모든 글자를 대문자로 작성한다
            - 단어의 구분은 Snake Case로 한다( _ 이용)

* :bulb: **연산, Operation, Operate**
    - 프로그램의 작동
    - 컴퓨터의 모든 작동
    - **연산자, Operator**
        - 연산을 기호로 나타낸 것이다
    - **피연산자, Operand**
        - 연산의 대상(값, 상수, 변수 등)
    - **연산자를 구분하는 기준**
        - 피연산자의 개수
            - 단항연산자, Unary Operator
	        - 이항연산자, Binary Operator
	        - 삼항연산자, Ternary Operator
        - 연산의 기능에 따른 분류
            - 산술 연산자 (+, -, *, /, %)
	        - 관계 연산자 (>, <, >=, <=, ==, ===, !=)
	        - 논리 연산자 (&&, ||, !)
	        - 대입 연산자 (=, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=, >>>=)
	        - 비트 연산자 (<<, >>, >>>, &, |, ^, ~)
	        - 기타 연산자 (참조 . , 형변환 (type), 삼항 (조건식)? (참):(거짓) )

* :bulb: **공백문자, White Space**
    ```java
	SP, SPace
    - 띄어쓰기		' ' (ASCII 32)
	
    LF, Line Feed, New Line
    - 개행, 줄바꿈	'\n' (ASCII 10)
	
    HT, Horizontal Tab
    - 탭, 수평탭	'\t' (ASCII 9)

	** 개행(줄바꿈)은 운영체제에 따라 '\r' 과 '\n'을 조합해서 사용한다
    ('\r' - CR, Carriage Return, '\n' - New Line)
    *Carriage Return: 맨 첫 칸으로 커서를 이동시킨다.
	*New Line: 다음줄로 커서를 이동시킨다.

	윈도우 : '\r''\n' 두 문자를 합쳐서 사용함
	리눅스 : '\n'
	맥OS : '\r' 이었는데 요즘엔 '\n'

    *Form: 종이
	*Feed: 먹이 - 종이를 먹는다. 종이가 타자기 안으로 들어감. Page Down과 같은 것
	*Line Feed: 줄 먹이기, 한 줄을 먹인다.
    ```

* :bulb: **데이터 입출력**
    - **키보드 = 표준입력, Standard Input (Stdin)** -> 키보드가 없으면 컴퓨터가 실행되지 않기도 한다.
    - Java에서는 Stdin을 **System.in** 으로 표현한다. Java에서 키보드의 입력을 받아들이는 API가 System.in이다. 프로그램의 **입력스트림**을 통해서 입력.
    - 입력의 기본이 키보드였다면, 출력의 기본은 모니터다. **모니터 = 표준출력, Standard Output (Stdout)**
    - Java에서는 Stdout을 **System.out** 으로 표현한다. Java에서 모니터로 출력하는 API가 System.out이다. 프로그램의 **출력스트림**을 통해서 출력. (스트림은 SW 프로그램이다)
    - System.in과 System.out을 합쳐 **System.io**라고 부른다.
    - 프로그램 내에서는 빠르게 작동하지만, 스트림을 통해 장치를 오갈 때 장치는 느리게 반응한다. 그래서 입출력은 굉장히 느리다. **이것을 보완하기 위해 임시저장소 Buffer를 만들어 여기에 출력사항을 기록한다.** 그리고 프로그램은 다른 일을 시작한다. 모니터는 Buffer에서 조금씩 가져와 일을 한다. 그러면 **프로그램과 모니터의 작업이 구분된다.** 프로그램은 Buffer에 데이터를 저장시키고 다른 일을 하게 되고, 모니터는 자신의 속도에 맞게 작업을 처리할 수 있다.
    ```java
	키보드 ---(입력스트림)---> 프로그램 ---(출력스트림)---> 모니터
	// 입력스트림, 출력스트림에 Buffer 있다.
    ```
    - 이번엔 입력 Buffer를 생각해보자. 초기 콘솔 입력 창에 "123\n" 을 입력했다고 치자. nextInt는 입력 Buffer 안에 있는 정수를 찾아서 프로그램으로 가져오는 기능을한다. **(123만 가져옴)** 프로그램으로 가져온 데이터는 Buffer에서 지운다.
    - nextLine은 입력 Buffer 안에 있는 개행문자'\n' 전까지의 데이터와 개행문자'\n'을 프로그램으로 가져온다. 그런데 입력 Buffer 안에는 123이 지워지고 현재 **'\n' 밖에 남지 않았다.** 그래서 뭔가를 입력할 새도 없이 **'\n'을 인식하여 바로 다음 출력될 문자열이 출력된다.**
    - 이것을 해결하기 위해서는 **남아있는 '\n'을 지워줘야 한다.** 그래서 중간에 **sc.nextLine();**을 넣어주면 된다. (sc는 변수명) 이것이 남아있는 '\n'을 가져갈 것이다.
    ```java
    ** 버퍼에서 해당 데이터타입의 자료만 가져가는 기능들 (개행문자 \n 은 남긴다)
    next()
    nextInt()
    nextDouble()
    nextBoolean()
    nextByte()
    nextShort()
    nextLong()
    nextFloat()

    ** nextLine()은 문자열을 가져가고 개행문자를 지워준다 

    이런 차이로 버퍼이슈가 생긴다.
    ```
    
    ```java
    Scanner sc = new Scanner(System.in);
    //스캐너 클래스의 객체 sc는 참조형이다.
    ```
    - 변수 sc를 선언하면 변수 공간A가 생성된다. 그 공간A에는 값이 저장되진 않고, 값을 지니고 있는 또 다른 공간B의 **주소**가 있다. 
    - 키보드를 통해 입력된 값이 공간B에 저장된다. 변수를 활용하면 변수에 저장된 **주소**를 읽고, 공간 B에 입력된 값을 가져온다.

* :bulb: **제어문, Control Statement**
    - 프로그램의 기본 진행 흐름(**위->아래**)을 변경(제어)하는 구문
    ```java
	** 프로그램의 기본 진행 : 메인 메소드에서 시작하여 코드를 한 줄씩 순서대로 전부 실행하는 것

	ex)	**프로그램의 메뉴
		
		1. 새로 만들기
		2. 옵션
		3. 끝내기

		선택: _ 
		
		(Java는 클릭이 아니라 명령프롬프트와 같은 콘솔창에서 진행된다)
    ```
    - 조건에 따라 **프로그램의 진행흐름을 바꾸는 것**이 제어문이다. 개발자가 원하는 흐름으로 프로그램을 제어할 수 있게 된다.
    - **제어문의 종류**
        - **조건문, condition** : if, else, else if
        - **반복문, loop** : for, while, do-while
            ```java
            for문에서 조건식을 작성할 때,
            초기식은 0으로 사용하는 것이 일반적이고 
            조건식은 되도록 등호 없이 하는 것이 좋다. 
            (>= or <= 가 아니라 > or <으로)
            ```

            ```java
            for문 중첩으로 별찍기를 해보니, 알게 된 것이 있다. 
            for문의 정수형 변수 i,j을 단순히 행과 열로 보기보다, 
            조건식을 통해 찾아야 하는 반복횟수로 보는 것이다.

            i가 몇일 때 j가 얼만큼 반복되어 가로로 이어지는지, (개행은 ln으로 해결)
            
            - 초기식의 시작은 0으로 설정
            - 조건식의 부등호는 등호가 없이 초과, 미만으로만 설정
            - i의 조건식은 행을 보고 정하고,
            - j의 조건식은 반복 횟수를 보고 정하는 것이다.
            ``` 
        - **선택문, selection (조건문에 포함됨)** : switch
        - **기타 제어문** : break, continue

* :bulb: **배열, array**
    - 같은 자료형의 여러 변수를 하나의 묶음으로 사용하는 것
    - 여러개의 변수를 한 번에 선언(생성)할 수 있다
    - 선언되는 변수들의 이름을 고민하는 노력이 줄어든다
    - 한꺼번에 선언된 변수 공간들을 인덱스(index)를 이용하여 관리한다
    - **배열의 선언 ( arr = 주소공간 )**
        - 배열 공간에 대한 참조값을 저장할 수 있는 변수 선언
        ```java
        데이터타입[] 배열명;
        ex) int[] arr; //추천
            char[] chArr;
            double[] dbArr;

        데이터타입 배열명[];
        ex)	int arr[]; //비추천
            char chArr[];
            double dbArr[];
        ```
    - **배열 생성 ( arr[0] = 데이터공간 )**
        - 실제로 데이터를 저장할 수 있는 변수공간(요소, Element)을 생성한다
        ```java
       	new 데이터타입[개수]

        ex) int[] arr; //배열 변수 선언
            arr = new int[10]; //배열 생성
            
        ** 배열의 크기(길이)(size, length)는 양수로 지정해야만 한다 ">=1"
        음수로하면 에러난다 negative size
        ```
    - **배열의 요소 접근(활용)**
        - 일반 변수처럼 사용하면 되고, index 번호까지 명시해줘야 한다
        - 배열의 인덱스(index)를 이용하여 요소(Element, 구성요소, 저장공간)에 접근한다
        - 인덱스는 0부터 시작하여 1씩 증가한다. (for반복문도 0부터 시작하게 했다. 비슷하다. 그래서 배열과 반복문을 조합해서 사용하는 경우가 많다)
        - 인덱스로 음수를 사용할 수 없다
        - 배열의 크기를 벗어난 인덱스를 사용할 수 없다
        ```java
        ex) new int[10];
		    0~9의 인덱스를 가진다
		    -> 0~'lenght-1' 만큼만 사용가능하다
        ```
* :bulb: **플래그, flag**
    - 깃발이라는 뜻
    - 특정 상황이나 상태 등을 기억하기 위해서 사용한다
    - 다른 프로그램이나 다른 로직에 신호를 보내기(남기기) 위해 사용하는 값(변수)
    - programming에서는 주로 boolean변수를 사용한다 (+ int도 사용한다. 상황이 3가지 보다 많을 때)
    ```java
    ex)	boolean isPositive = false; //플래그
	
		if (num>0) {
		  isPositive = true;
		}

		if(isPositive){
		  System.out.println("양수입니다");
		}else {
		  System.out.println("양수가 아닙니다");
		}
    ```
    - 프로그램의 로직이 끝나는 시점과 결과값이 나오는 시점이 다를 때 사용하면 편하다
    - 로직을 처리하는 도중 결과값이 나오지만, 결과값에 상관없이 끝까지 실행되어야 하는 경우 결과값을 플래그로 저장해 놓는다

---

### :pushpin: Java의 시작

* :bulb: **객체지향 프로그래밍, OOP(Object Oriented Programming)**
    - 객체들을 중심으로 상호작용(데이터 전달, 교환)을 통해 프로그램이 작동되도록 작성하는 프로그래밍 기법
    - 객체마다 **고유의 기능**이 있다. 이 기능은 각각 스스로 활용할 수 있다. 그러나 다른 기능을 이용하려면 통신을 해야 한다
    - **Q: 객체마다 어떤 고유의 기능이 있는가? Q: 그 기능을 어떻게 만드는 것인가?**
    - 객체는 '같은 기능을 가진 집합체'라고 말할 수 있다.
    - 객체의 큰 목적 중의 하나가 '현실세계를 반영'하자는 것이다.
    - 프로그램 코드를 일부 명령어들의 나열로 보지 말고, 명령어들의 **집합체**(=객체)를 중심으로 생각하자. 작게 보지 말고 크게 묶어서 보자.
    - Why? 절차지향프로그래밍(Procedural Programming) : 이것은 코드가 순차적으로 실행된다. **순차적으로 실행될 때의 단점**은 무엇일까? 만약에 코드의 밑에서 **이전에 실행했던 기능을 사용한다면 코드의 위로 올라갔다가 다시 밑으로 내려오거나, 이전의 코드를 현 위치에서 그대로 다시 써내려가야 한다.** 이런 복잡함을 해결하기 위해 **기능이 있는 코드를 처음부터 따로 생성하여, 불러오는 방식**이 객체지향 프로그래밍이다.
    * :bulb: **객체, Object**
        - 현실 세계에 존재하는 모든 것들.
        - 프로그램에서 구현(표현)하고자 하는 모든 대상. 이것을 객체라고 본다
    * :bulb: **클래스, Class**
        - 객체를 만들기 위해서 코드로 작성한 것
        - 객체(현실대상을)를 추상화한 것
        ```java
    	[접근제한자] [클래스식별자] class [클래스명] {
		    //멤버 필드
		    //멤버 메소드
	    }
        public final class className { //클래스 식별자는 없어도 됨
            private int num = 10;
            private String word = "name";
            public void methodName (parameter) {
                //code
            }
        } 
        ``` 
    * :bulb: **추상화, Abstraction**
        - **수많은 데이터 중에서 필요한 데이터만 선별한 것**
        ```java
        ex)
        프로그램 목표 : 주소록(이름, 전화번호, 주소)
        
        객체(현실세계 대상)
        -> 사람의 데이터
            이름 *
            나이
            출생지
            주민번호
            전화번호 *
            주소 *
            학력
            친구목록
            ...
            
        수많은 데이터들이 있어도 필요한 것은 소수다.

        전체 데이터 중에서 필요없는 데이터는 버리고
        필요한 것만 선택해오는 것을 "추상화"라고 한다
        ```
         - 객체에는 너무 많은 정보가 있다. 필요없는 정보도 있다. 여기서 필요한 데이터만 뽑아서(추상화해서) 클래스를 만드는 것이다.
        ```java
                                            (인스턴스화)
                        (추상화)             (객체 생성)
        현실 세계 대상 -------------> 클래스 -------------> 객체, Object
        (객체, Object)               (class)                (Instance)
                                                            메모리에 저장된 정보를 의미
        ```
        - 현실의 정보(객체)를 필요한 것만 코드로 작성(클래스)하여 프로그램 안에 저장(인스턴스)시킨다
        - class의 이름은 그 정보의 주제로 한다
        - 프로그램으로 아직 만들지 않은 정보도 '객체'라 부르고, 프로그램으로 만든 것도 '객체'라고 부른다. 그러나 프로그램 안의 객체는 '인스턴스'라고도 부른다.
        - (현실세계대상)객체의 공통적인 속성, 기능, 행위 등을 개념화하는 작업
        - 프로그램에서 필요한 요소들만 집중해서 정리해야 한다. **프로그램에서 필요로 하지 않거나 중요하지 않은 요소는 무시한다**
    * :bulb: **인스턴스, Instance**
        - 메모리에 생성된 **객체**
        - **클래스(class) 코드를 통해서 생성된 실체(객체)**
        - **new가 메모리에 인스턴스 공간을 생성하는 코드다.** 그러면 이제 변수가 이 공간을 참조하는 것이다
    * :bulb: **인스턴스화, Instantiate**
        - 인스턴스로 **만드는 것**
        - 메모리에 실제화하는 **작업**
        - 메모리를 차지하게끔 **공간을 생성하는 것**
        ```java
            클래스 -----> 인스턴스(객체)
            (코드덩어리)    (메모리를 차지하는 실제 공간)
            (자료형)        (변수)
            (건축설계도)    (건물)
        ```
    * :bulb: **접근제한자, Access Modifier**
        - **private, default(package), protected, public**
        - 사용 목적: 현실세계의 객체에서 컴퓨터의 클래스로 정보가 이동할 때 **추상화**가 있었다. **그래서 꼭 있어야 하는 정보만 클래스에 있다.** 클래스에 있는 정보는 중요하게 다뤄진다. 클래스에 있는 '멤버필드'와 '멤버메소드'는 중요하다. 지워지면 안 되므로 **안전하게 보관**하려고 했다.
        - 그런데 이를 일반 변수로 설정하면 누구나 접근이 가능하니까 보안을 높여서 접근을 제한하려고 한다. 그래서 접근제한자를 만들었다. 클래스의 정보를 보호하기 위해.
        - 객체의 멤버필드(고유한 속성), 멤버메소드(고유한 동작과 기능)에 대한 **정보를 외부에 함부로 공개하지 않기 위해 사용한다.** (이런 여러 개념들의 사용목적을 알면 활용도가 높아지고, 면접 때도 물어본다)
        - 객체는 추상화 이후의 결과물이 된다. -> 프로그램에서 중요한 정보만 추출한 것
        - 객체의 멤버를 외부에서 함부로 접근하면 프로그램에 악영향을 끼칠 수 있다. 그래서 안전하게 써야 한다. 외부 접근을 차단하려고 한다. -> 모두 막는 건 아님. 일부는 열고 일부는 닫는다.
	    - 필요한 정도까지만 멤버를 공개하고, 나머지는 제한한다.
        - **접근제한자의 종류**
            - 종류에 따라 정보를 공개하는 정도가 달라진다
            - **private(-)** : 해당 **클래스 내부에서만 접근 가능.** 바깥쪽에서는 뭐가 있는지도 모른다.
            - **default** : **같은 패키지 안에서만 접근 가능.** 같은 패키지의 클래스들끼리 상호작용하게 함. 같은 기능, 같은 목적을 지닌 클래스들끼리 한 패키지에 묶음. (키워드 X, 변수 앞에 아무것도 안 적으면 적용된다)
            - **protected(#)** : **같은 패키지 + 상속 관계의 객체까지 접근 가능.** 다른 패키지라도 상속 관계면 접근 가능하다
            - **public(+)** : 모든 접근 허용
        - **공개범위** : **private < default < protected < public**
        - **접근제한자를 적용할 수 있는 위치**
            - **멤버 필드** : 4가지 전부 적용가능 (주로 private을 적용)
            - **멤버 메소드** : 4가지 전부 적용가능 (주로 public을 적용)
            - **클래스 정의코드** : public 또는 default
    * :bulb: **메소드, Method** = 객체의 기능
        - 함수, function <- 객체의 의미보다 포괄적이다. 자바는 객체로 구성되어 있기 때문에 특정 기능을 객체라고 부르는 것이 함수보다는 어울린다. 그러나 '기능'을 하는 것은 같기에, 큰 차이는 없다.
        - 클래스(객체)의 기능, 동작, 행위 등을 정의하는 코드
        - **메소드를 사용하려면 객체 변수를 통해서 호출해야 한다**
        - **객체들 간의 데이터 전달 수단**
        ```java
            [접근제한자] [리턴타입] [메소드명] ( 매개변수 ){
            (*주로 public)         (*소문자 시작)
                //실행 코드	        
            }
            public void methodName (parameter) {
                //code
            }
        ```
        - 자바의 메소드를 호출할 때 전달인자로 절대! 변수공간을 전달하지 않는다.    
            - 변수에 저장되어 있는 '값'만을 복사하여 전달한다
	        - 전달되는 값의 자료형은 참조형일 수도 있고 기본형일 수도 있다.
        - **Call By Value, 값에 의한 호출**
        메소드 호출시, 전달되는 인자의 값이 **기본형 데이터**일 때
        - **Call By Reference, 참조에 의한 호출**
        메소드 호출시, 전달되는 인자의 값이 **참조형 데이터**일 때
        - Call By Value 상황에서는 매개변수의 값을 변경해도 **원본(메인메소드의 변수)은 그대로 유지**된다. Call By Reference 상황에서는 매개변수를 통해서 참조한 공간의 값을 변경하면 **원본에서도 변경된 데이터**를 확인할 수 있다. -> 참조값만 복사되는 얕은복사(Shallow Copy)가 된 상황이다.
        - **메소드에서 return코드의 역할**
            1. 반환값 지정하기
	        2. 메소드 종료하기
        - 반환 데이터타입이 void일 경우 반환값을 지정할 수 없다.
		    - return; <- 이렇게만 사용할 수 있다. 바로 세미콜론으로 마무리.
		    - 반환값 없이 메소드 종료시키는 역할만 수행할 수 있다.
        - 우리가 계속 쓰는 'main()메소드'의 반환타입이 void이므로 return; 코드 사용이 가능하다.
    * :bulb: **클래스, class**
        - **클래스의 접근제한자**
            - public 또는 default(안 붙이는 것)
	        - public 접근제한자 적용 : **어디에서든지 사용**할 수 있는 클래스가 된다. '.java' 파일 안에는 딱 하나의 클래스만 public을 붙일 수 있다. '.java' 파일의 이름과 클래스명이 같아야 한다. -> public클래스는 해당 '.java'파일의 주된 클래스가 된다.
            - default 접근제한자 적용 : **같은 패키지에서만 사용**할 수 있는 클래스가 된다. public클래스의 보조기능을 담당하는 클래스를 만들 때 사용한다. 요즘에는 default클래스를 안쓴다. 보조기능도 그냥 public으로 만들고 패키지로 묶는다. 클래스를 엄청 많이 만든다. 5~60개.
        - **클래스 식별자(제한자, modifier)**
            - 클래스의 용도에 따라서 특별 기능을 부여할 때 사용한다.
            - abstract, final, static 등등...
        - **클래스명**
            - 첫 글자를 대문자로 시작
        - **멤버 필드 (클래스를 사용하는 이유1)**
            - 클래스 코드를 구성하는 변수, 상수 (but, 주로 변수)
            - 설계도. 실제 공간이 만들어지는 시기는 인스턴스화 할 때이다.
            - 객체가 생성될 때, 각각의 인스턴스(객체)마다 변수공간을 만들어 준다. 이때 변수가 된다!
            - 즉, 객체를 생성하기 전까지는 실제 공간이 없는 것이다.
        - **멤버 메소드 (클래스를 사용하는 이유2)**
            - 객체의 기능, 행위를 정의한 코드
        - **멤버필드**와 **멤버메소드**가 있어야 클래스가 된다. + 기본으로 **생성자**도 있음
    * :bulb: **객체변수**
        - 선언
        ```java
        [클래스명] [객체변수명];
	    ex) Test t1;
        ```
        - 생성
        ```java
        [객체변수] = new [클래스명]();
	    ex) t1 = new Test();
        ```
        - 객체의 멤버에 접근
        ```java
        [객체변수].[멤버필드];
	    [객체변수].[멤버메소드]();
	    ex) t1.num = 100;
		    t1.print();
        //'.' 참조연산자를 이용하여 멤버에 접근한다
        ```
    * :bulb: **캡슐화, Encapsulation** <- 클래스의 큰 특징
        - 객체지향프로그래밍의 특징 중 하나. 클래스를 캡슐화해서 만든다.
        - **객체의 속성과(멤버필드) 기능(멤버메소드)을 하나의 클래스로 묶어 표현한다.**
        - 프로그램에 필요하고 중요하고 서로 연관 있는 데이터와 기능들을 추출해서 하나의 클래스에 모아놓는다 = 추상화 + 캡슐화 (꼭 하나의 클래스에 작성하는 것은 아니다. 여러 클래스일 수도 있다)
        - 객체를 표현하는 **정보**(데이터, 멤버필드)와 정보들을 다루는 **기능**(멤버 메소드)을 같은 클래스로 묶어서 정의한다.
        - 속성(필드)은 중요한 정보이므로 외부에 함부로 공개하지 않도록 처리한다
	        - 정보은닉, Information hiding
	        - 필드에 접근제한자를 적용하여 처리한다
            - 캡슐화 개념 안에 정보은닉이 있다
        - **멤버필드는 private을 적용한다**
        - **멤버메소드는 public을 적용한다** - getter, setter 메소드를 통해 private로 은닉되어 있는 필드에 접근한다
    * :bulb: **Getter Method**
        - 멤버필드의 값을 "가져올" 수 있도록 작성한 메소드
        - 작성할 때 규칙: 메소드의 이름을 반드시 "get"으로 시작하고, 멤버필드명 첫 글자만 대문자로 바꿔서 사용한다
        - 형식	
	    ```java
        public [필드의 자료형(리턴타입)] getXxxx(){
	        return [필드명];
	    }

        ex) private int num; 
        //추상화를 거친 중요한 정보이기에 접근제한자 private로 은닉된 멤버필드

	    public int getNum() { 
            //1. 멤버메소드라서 public으로 시작
            //2. 필드의 자료형이 int형이라서 그대로 따라 씀. 
            //3. getter메소드를 이용하려고 하기에 이름 명명 규칙 따라서 getNum()으로 작성
	        return num; //가져오자! private로 은닉된 num을!
	    }
        ```
    * :bulb: **Setter Method**
        - 멤버필드의 값을 "저장"할 수 있도록 만든 메소드
        - 메소드명을 "set"으로 시작하고, 멤버필드명 첫 글자만 대문자로 바꿔서 사용한다.
        - 형식
        ```java
        public void setXxxx([필드의 자료형] [필드명]) {
            this.[필드명] = [필드명];
        }

        ex) private int num; 
        //추상화를 거친 중요한 정보이기에 접근제한자 private로 은닉된 멤버필드

        public void setNum(int num) {
            //1. 멤버메소드라서 public으로 시작
            //2. 그 다음에 void를 쓰는 것이 기본
            //3. setter메소드를 이용하려고 하기에 이름 명명 규칙 따라서 setNum()으로 작성
            //4. 형식을 따라 자료형과 변수명을 쓴다
            this.num = num; //여기 클래스에 있는 private로 은닉된 멤버필드 num에 매개변수(인자)로 받은 num을 저장하겠다!
        }
        ```
        - **this 키워드(자기 참조 객체)**
            - 클래스를 정의하는 코드에서 클래스 자기 자신을 나타낼 때 사용한다. 'this.'을 이용하여 자신의 멤버필드, 멤버 메소드를 지칭할 수 있다.
        - Source 메뉴를 팝업으로 띄우는 단축키 : alt + shift + s
        - getter, setter 띄우는 단축키 : alt + shift + s 후 r
    * :bulb: **클래스에서 사용되는 변수의 유형**
        - **인스턴스 변수, Instance Variable (파란색 글자)**
            - 일반적인 '멤버 필드'에 의해서 만들어진 변수.
            - 객체 생성(인스턴스화)하면 각 인스턴스마다 변수공간을 따로 가진다
        - ***클래스 변수, Class Variable (기울인 파란색 글자)***
            - static키워드를 적용한 '멤버필드'에 의해서 만들어진 변수. 
            - 클래스변수의 변수공간은 클래스당 단 "한 개"만 만들어진다. (인스턴스마다 만들어지지 않는다) 
            - 프로그램이 동작하기 전에 미리 클래스 영역에 생성한다
            - 같은 클래스타입으로 만든 객체들이 모두 같은 하나의 공간을 공유한다
            - 접근할 때 [클래스명.클래스변수] 형식을 사용한다 = static way
            - (우리의 개발과정에서는 클래스변수를 거의 사용하지 않을 것이다 그러나 API에서는 많이 제공된다)
        - **지역 변수, Local Variable (갈색 글자)**
            - 메소드 내에서 선언된 변수 = 메소드명(){ } 에서 { }안에서 선언된 변수
		    - 그동안 main 메소드 안에서 변수를 선언하고 생성한 것이 이것이다
            ```java
            매개변수도 지역변수로 취급한다.

            접근제한자를 적용할 수 없다. 숨기고 말고 그럴게 없다.
            어차피 밖에서 사용할 수 없다.
            그러나 매개변수를 통해 return하여 
            값만 이동시킬 수는 있다

            메소드가 호출될 때마다 각자의 공간을 생성하고 
            그 안에 지역변수를 저장한다
            (Stack Memory 영역)

            초기화하지 않으면 쓰레기값을 가지게 된다
            ```
    * :bulb: **static 키워드**
        - 클래스의 멤버를 객체 생성없이 사용할 수 있게 해주는 키워드
        - 멤버 필드, 멤버 메소드 모두 적용할 수 있다
        - 인스턴스와는 무관하게 사용할 수 있다
        - 클래스단위로 제어한다
        - 정적인 시점에 사용 준비가 완료된다
        ** 정적인 시점 : 프로그램 동작을 준비하는 시점, 코드 실행 전
        - 정적 멤버필드 : 클래스 영역에 변수공간을 생성한다
        - 정적 멤버메소드 : 곧바로 실행 가능하도록 모든 준비를 마친다
        - 특이사항
            - 정적(static)메소드에서 인스턴스변수 사용 불가
            - 정적(static)메소드에서 정적 변수만 사용 가능
            - 일반 메소드에서 인스턴스변수, 정적(static)변수 둘 다 사용 가능

* :bulb: **생성자, Constructor**
    - 생성자의 접근제한자는 보통 public이지만, private와 default가 쓰이는 경우도 있다.
    - 멤버필드와 멤버메소드가 없어도 생성자는 필요하다. **클래스를 구성하는 요소다**
    - **클래스에는 한 개 이상의 생성자가 반드시 있어야 한다. 수동으로 추가하지 않아도, JVM이 default생성자를 자동으로 하나 추가한다.** 그래서 존재를 몰랐던 것이고, 에러가 안났던 것이다. 그러나 클래스에 하나라도 개발자가 정의한 생성자가 있으면, JVM이 자동으로 default 생성자를 추가하지 않는다.
    - 기본적인 생성자의 {}안에는 아무것도 적지 않는다. 생성자는 아무런 역할을 하지 않는다. 존재만 한다. = default 생성자 (매개변수가 없는 생성자)
    - 역할이 뭔가? **멤버필드의 값을 초기화시켜준다. 객체생성 이후 처음으로 저장될 값을 대입한다.**
    - 초기화를 간단하게 할 때는 처음부터 멤버필드에 값을 대입하면 된다. 그러나 복잡한 처리과정이 필요하다면 생성자를 이용한다.
    - 객체를 만들 때 반드시 생성자를 호출하여 만들어진다. 생성자를 호출하고 나면 인스턴스가 만들어진다.
    * **생성자의 형태**
        - 클래스, 멤버필드, 멤버메소드, 객체의 형식과 정확히 구분하여 외우자!!
            ```java
	        [접근제한자] 클래스명(매개변수) {
	            //객체를 생성하면서 수행할 작업(코드)
	        }
            ```
        - 메소드와 다른 점은, [반환타입] 과 반환코드(return;)를 작성하지 않는다
        - **생성자의 이름은 클래스명과 같아야 한다.** 상단의 생성자 형태에서, 클래스명이 생성자명이다.
        - **오버로딩 가능**
    * **생성자의 역할**
        - 생성될 **객체(인스턴스)의 초기값을 설정**한다
        - 멤버필드가 처음 가져야 할 값을 설정할 때 사용한다
        - 생성자는 객체를 생성할 때 수행된다
* :bulb: **UML, Unified Modeling Language**
    - 통합 모델링 언어(도구)
    - 프로그램의 외적(계획, 일정, 목표, 인력), 내적(요구사항에 맞는 기능)인 것들을 "기획단계"에서 수행한다.
    - 클래스 종류, 패키지 구분, 메소드 이름 등 '어떻게 만들어야 하는가?'에 대한 답을 하며 구체적인 부분을 "설계단계"에서 수행한다
    - 코드로 "구현"을 해서 완성한다
    - **기획, 설계, 구현의 모든 사항이 "문서"로 남아야 한다. 이 문서의 작성법이 UML이다.**
    - 기획, 설계, 구현으로 이어지는 프로그램 개발 과정에서 발생하는 중간 산출물을 표현하기 위해 만들어진 "표준화"된 모델링 언어
    - 프로젝트 참가자들이 의사소통을 원활하게 할 수 있도록 도와준다. UML이 없다면 개인의 방식을 따라 다른 형식으로 일할 것이다
    - 우리한테 필요한 UML 산출물
        - **화면정의서**
            - 화면 구현을 위한 설계서
        - **스토리보드, story board**
            - 프로그램 시작~종료까지 페이지 동작과정과 실행되는 기능들 하나하나 말과 그림으로 설명하는 것 
        - **요구사항 명세서, 정의서**
            - 프로그램의 요구사항을 정리한 문서
            - 명세서: 자세히 작성한 것
            - 정의서: 요약작성한것
        - **유스케이스 다이어그램**
            - 요구사항에서 기능들 위주로 표현한 그림
            - 프로그램을 사용할(동작시킬) 행위자(Actor)를 중심으로 기능을 표현한 것
        - **클래스 다이어그램**
            - 클래스의 구조를 표현한 그림
        - **시퀀스 다이어그램**
            - 클래스의 동작(기능)을 표현한 그림
        - **패키지 다이어그램 (필수x)**
            - 프로그램 코드의 패키지를 표현한 그림
        - **ER 다이어그램**
            - DB를 설계한 것
    * **클래스 다이어그램**
        - 프로그램을 설계할 때 클래스의 형태, 구조, 클래스들의 관계 등을 그림으로 표현한 것
        - SW의 논리적인 구조를 표현한다. 논리적인 구조 = 클래스의 내부 구조 + 클래스들간의 관계
        - 클래스의 정적인(안 바뀌는) 구조를 표현한다. (동적인 것, 동작을 보여주는 것은 시퀸스 다이어그램에서 한다)
        ```java
        ------------
        ㅣ클래스 명 ㅣ 와 같은 식으로 단계를 나눠서 구현하는 것이다.
        ------------
        ㅣ멤버 필드 ㅣ 클래스 사이의 관계는 여러가지다. 포함, 연관, 참조 등등..
        ------------
        ㅣ멤버메소드ㅣ
        ------------
        ```
    * :bulb: **접근제한자 표현 기호**
        ```java
        + : public (초록색)
        # : protected
        ~ : default
        - : private (빨간색)
        ```
        ```java
        ex)	멤버필드 표기 예시 '접근제한자기호' [변수명] : [데이터타입]

            private String name;    ->	- name : String
            public int num;         ->	+ num : int
            double height;          ->	~ height : double

    	ex)	멤버메소드 표기 예시
		
            public String getName() { } ->  + getName() : String
                                        '접근제한자' 메소드명() : 리턴타입

            private double display(int n1, int n2) { }  ->	- display(int, int) : double
                                                    '접근제한자' 메소드명(매개변수의 자료형) : 리턴타입
        ```
    * :bulb: **스테레오 타입, Stereo type**
        - 클래스의 특수한 기능을 표현할 때 사용한다
        - <<특수 기능>> 처럼 사용한다.
        ```java
	    ex)
		<<constructor>> = 생성자
		+ Person()

		<<getter>> = getter메소드
		+ getName() : String
        ```
* :bulb: **상속, Inheritance**
    - 코드의 중복이 있으면, 그 **중복을 줄이기 위해** 상속을 쓰려고 한다.
    - 중복되는대로 코드를 쓰면, 재사용성과 확장성이 떨어진다.
    - 상속을 통해 클래스의 중복되는 코드를 한 번에 관리할 수 있다. 수정시 수정할 코드가 적어진다.
    - (클래스명 뒤에) **extends [부모 클래스 이름] {}**
    - 메소드를 호출하는 것과 비슷한 것 같지만, 코드를 정의하는 것과 수행하는 것은 다르다.
        - 클래스를 정의하여 클래스 안의 코드를 그대로 붙여넣는 것처럼 가져다 쓰는 것은 "코드를 정의하는 개념인 상속"이고
        - 메소드를 호출하여 메소드 안의 코드를 수행하는 것이 "코드를 수행하는 것"이다.
    - **기존의 클래스 코드를 재사용하여 새로운 클래스를 작성**할 수 있게 하는 문법. (필요한 부분을 수정하고, 추가한다)
    - 상속을 주는 클래스(부모클래스)의 코드를 변경하면, 상속을 받는 클래스(자식클래스)들도 전부 반영된다
        - 상속을 주는 클래스 : 부모클래스, 수퍼, 상위, Based(기준의)
        - 상속을 받는 클래스 : 자식클래스, 서브, 하위, Derived(유도된, 파생된) -> 클래스들 간의 관계가 형성된다. 추후 다이어그램에 작성.
    - **상속의 문법**
    ```java
    class Parent {
	  int n1;
	  int n2;
	  String name;
	}

	class Child extends Parent {

	}

	-> Child 클래스는 Parent의 모든 멤버를 상속받는다. (멤버필드, 멤버메소드, 생성자)
	-> Child 클래스는 멤버를 작성하지 않아도 Parent의 멤버를 가지고 있는 것처럼 사용할 수 있다
    ```
* :bulb: **오버라이딩, Overriding**
    - 메소드 재정의, **이전의 것을 무시하고 덮어 씌우는 것**
    - 상속받은 메소드를 자식 클래스가 새롭게 재정의하는 것
    - **기존의 코드를 덮어씌운다**
* :bulb: **오버로딩, Overloading**
    - 메소드 중복 정의
    - 같은 이름의 메소드를 매개변수의 개수 또는 타입, 순서를 다르게 작성하여 **다른 메소드를 추가 정의하는 것**
    - **오버로딩 성립 조건**
        1. 메소드 이름이 같을 때 적용된다
	    2. 매개변수의 자료형의 종류 또는 개수 또는 순서가 달라야 한다
	    3. 리턴데이터타입은 오버로딩과 상관없다
* :bulb: **바인딩, Binding**
    - 메소드의 호출코드(사용)와 메소드의 정의코드(구현)가 연결되는 과정
    - **정적 바인딩 : 프로그램 실행 전 바인딩 되는 것**
	    - 메소드 호출하는 객체변수의 데이터타입만 보고 바인딩된다.
    - **동적 바인딩 : 프로그램 실행 중에 메소드가 호출될 때 바인딩 되는 것**
	    - 동적생성된 인스턴스의 데이터타입을 보고 바인딩된다
    - 자바는 기본적으로 동적 바인딩을 수행한다. 메소드가 호출될 때 메소드의 정의코드와 연결된다.
* :bulb: **super 키워드**
    - super.
        - 상속받은 부모객체 참조
        - **자식클래스에서 부모클래스의 멤버에 접근할 때 사용한다**
        ```java
        ex) this.num = 10; //자식클래스의 멤버 num
            super.num = 20; //부모클래스의 멤버 num

            //메소드가 오버라이딩 되어있는 상황일 때
            this.display(); //오버라이딩한 메소드
            super.display(); //오버라이딩 전 부모 메소드
        ```
    - super()
        - 수퍼 생성자 호출, 부모클래스 생성자 호출
        - 자식클래스의 생성자에서 부모클래스의 생성자를 호출할 때 사용한다
	    - 직접 super() 호출 코드를 작성하지 않으면 자동으로 부모클래스의 디폴트 생성자를 호출한다
	    - 부모클래스에 매개변수 있는 생성자가 정의되어 있으면 전달인자를 넣어서 호출할 수 있다
        - **자식클래스의 생성자에서 첫번째 코드로 사용해야 한다**
* :bulb: **final 키워드**
    - 더 이상 확장할 수 없도록 설정하는 키워드
    - final 키워드의 적용 위치
        - **변수** : 딱 한 번만 초기화(대입)할 수 있도록 설정 변수를 상수화시킨다
        ```java
	    ex) public final int MAX = 5;
		    public static final int LEN = 10;
        ```
        - **메소드** : 더 이상 오버라이딩 할 수 없도록 설정
        ```java
	    ex) public final void out(){
	            //자식클래스에서 재정의(오버라이드) 할 수 없음
		    }
        ```
        - **클래스** : 더 이상 자식클래스를 생성할 수 없도록 설정
        ```java
	    ex) public final class Child() {
		        //상속을 줄 수 없게 된다
		    }
        ```
* :bulb: **for each 구문**
```java
for( [요소의데이터타입] [변수명] : [배열 or 컬렉션] ) {
    //for구문에 선언된 변수를 사용할 수 있다
}
```
- 배열이나 컬렉션의 모든 요소를 이용한 **반복작업을 쉽게 수행할 수 있도록 만들어진 반복문**
- 배열의 요소를 0번째부터 하나씩 변수에 대입하여 마지막 요소까진 반복한다
```java
ex)
    int[] arr = {1,2,3,4,5};
	
    for( int num : arr ) {
	    //num변수 사용 가능
	    System.out.println( num );
	}

    for(int i=0; i<arr.length; i++) {
	    //arr[i] 사용
    }
```
* :bulb: **다형성, Polymorphism**
    - 한 요소가 다양한 모습으로 표현되거나, 다양한 기능을 수행할 수 있음을 뜻한다
    - 부모클래스 타입의 객체변수를 이용하여 다양한 자식클래스 타입을 처리한다. 대입, 메소드호출(동적바인딩) 등
	```java
	ex)	Parent P1 = new Child1();
		Parent P2 = new Child2();
		Parent P3 = new Child3();
    ex)	public void out( Parent p ) {

		}
		out( new Child1() );
		out( new Child2() );
	```
* :bulb: **abstract 키워드**
    - 추상화 키워드
    - 클래스, 메소드에 사용할 수 있다 (추상클래스, 추상메소드)
    * :bulb: **추상 메소드**
        - 동작(실행)코드를 구현하지 않고 추상화시킨 메소드
        - 메소드의 구현부분(method body, 메소드 몸체, {}부분)을 작성하지 않고, 대신 ; 으로 끝낸다
        - 형태
        ```java
        [접근제한자] abstract [리턴타입] [메소드명](매개변수);
        ```
        - 추상메소드는 상속이 가능하다
        - 추상메소드를 멤버로 가지려면 반드시 추상클래스로 지정되어야한다
        - 추상메소드를 상속받는 자식클래스는 추상메소드를 처리해야만 한다
            - 방법1. 오버라이딩한다 (추상메소드->일반메소드)
	        - 방법2. 자식클래스를 추상클래스로 지정한다 (abstract class)
    * :bulb: **추상 클래스**
        - 실체화(인스턴스화)할 수 없는 클래스
        - new연산자를 이용하여 객체생성을 할 수 없다
        - 데이터타입으로 사용하여 객체변수를 만들 수는 있다
        - 추상 메소드를 멤버로 가질 수 있다
        - 반드시 추상 메소드를 멤버로 가져야하는 것은 아니다
        - 형태
        ```java
        [접근제한자] abstract class [클래스명] {

        }
        ```
* :bulb: **인터페이스, Interface**
    - 추상메소드와 상수만 멤버로 가지는 일종의 추상 클래스
    - 멤버필드(상수)는 자동으로 public static final 키워드가 적용된다
    - 멤버필드에 public, static, final 중 무엇이든 없어도 전부 자동 적용됨
    - 멤버메소드(추상메소드)는 abstract 키워드가 기본으로 적용된다
    - 멤버메소드에 abstract가 없어도 자동 적용됨
    - 사용 목적
        1. 상수들의 모음집 : 상수들만 따로 관리하기 위해 사용한다
        2. 메소드 개발 가이드 : 개발해야하는 메소드의 형식을 강제할 수 있다

### :pushpin: Java의 시작2
:bulb: **API, Application Programming Interface**
- 프로그램을 개발하기 위해 만들어진 코드들
- API: 응용 프로그램이 운영체제(OS)나 기타 시스템과 통신(상호작용)을 할 때 사용되는 메시지의 형식(함수, 메소드)
    - 자바에서는 클래스와 인터페이스 형태로 제공된다
    - 자바 프로그램을 개발하기 위해 제공되는 클래스들
    - 자바는 JDK에 포함되어 있다
    - Java API Specification Documentation을 참고해야한다 (API 설명서)
:bulb: **Random 클래스**
- 의사(꾸며진, 비슷하게 흉내낸) 난수를 생성하는 클래스
- 난수, Random
    - 무작위 수
    - 알 수 없는 값
- 의사 난수, Pseudo Random (pseudo, 수도, 슈도 : 가짜의, 꾸며진)
    - 실제 난수는 아니지만 마치 난수인 것처럼 만들어진 값 -> 컴퓨터에서 난수 대신 사용된다
- 컴퓨터에서 의사 난수를 생성하는 원리
    - 의사 난수의 기초값(seed)을 복잡한 연산을 통해 결과값을 만든다 -> 복잡한 연산을 거꾸로 추적하기 힘들게 만든 것
    - seed가 고정되거나 미리 연산식을 알고 있으면 결과 예측이 가능하다 -> 해결 : seed를 수시로 변경한다
    - 현재시간을 seed로 사용한다
        - 에포크 타임, Epoch Time : 1970년 1월 1일 00시를 기준으로 현재까지 흘러간 시간. 단위는 초, 밀리초
    - 처음 의사 난수는 현재 시간을 seed로 사용한다
    - 다음 의사 난수는 이전 의사난수를 seed로 사용한다
:bulb: **Object 클래스**
- 패키지 : java.lang - 자바의 기본이 되는 클래스들을 모아놓은 패키지 (import 선언없이 사용할 수 있다)
- 자바의 모든 클래스들의 최상위 부모클래스
* :bulb: **Object클래스의 메소드**
    - 재정의 불가능 메소드 (final키워드 적용되어있음)
	    - **notify, notifyAll, wait**   - 멀티스레드의 동기화에 사용
	    - **getClass**                  - 클래스타입으로 객체정보를 반환한다
    - 재정의 가능 메소드
        - **toString**
		    - 객체를 설명하는 문자열을 반환하는 메소드
		    - "데이터타입@참조값" 형식의 문자열을 기본적으로 리턴한다
		    - System.out.println(객체); 메소드는 객체의 toString()을 호출하여 리턴값을 출력한다
		    - 주로 재정의하여 객체의 멤버필드값이 출력되도록 사용한다
        - **equals**
		    - 객체의 동등성을 비교하는 코드로 재정의하여 사용한다
	        - 객체의 동일성을 비교하는 코드로 기본적으로 정의되어있지만, 실제 프로그래밍에서 사용할 때에는 재정의해서 사용한다
		    - 동일성(identity) - 같은 객체인가, 같은 참조값을 가지는가
		    - 동등성(equality) - 같은 데이터를 가지는가
            - String클래스는 equals()를 오버라이딩하고 있다
        - **hashCode**
		    - 객체의 고유한 값을 반환하는 메소드
		    - 객체의 참조값을 10진수로 반환하는 것이 기본 동작이다
            - String클래스는 문자열데이터를 이용해서 hashCode()를 오버라이딩하고 있다 -> 같은 문자열이라면 같은 hashCode가 나온다
        - **clone**
		    - 객체를 복사하여 반환하는 메소드
            - Object클래스에 protected 접근제한자로 설정되어있다
		    - 오버라이딩하여 public으로 변경하여 사용한다
            - 반환타입이 Object이므로 복사하려는 클래스로 형변환하여 사용한다
            - 예외 처리 구문(try ~ catch)이 필요하다
            - clone()메소드를 오버라이딩하는 클래스는 interface Cloneable을 상속해야만 한다
        	- 깊은 복사된 인스턴스의 참조값을 반환한다
        - **finalize**
		    - 객체가 소멸될 때 호출되는 메소드
		    - GC(Garbage Collector)가 객체를 파괴할 때 호출되는 메소드
		    - 건들지 말 것! 재정의하지말고, 사용도 하지마세요!
:bulb: **Wrapper 클래스**
- 기본 데이터타입을 포장하고 있는 클래스
- 기본 데이터타입의 데이터를 객체타입으로 사용할 수 있게 해주는 클래스들
- 기본 데이터를 참조형 변수로 사용할 수 있게 해준다
```java
	기본형		Wrapper클래스(참조형)

	boolean		Boolean
	char		Character (기본형과 이름 다름)
	byte		Byte
	short		Short
	int		    Integer (기본형과 이름 다름)
	long		Long
	float		Float
	double		Double
```
* :bulb: **박싱, Boxing**
    - 기본형 -> 참조형
    - Wrapper클래스의 생성자를 이용한다
    ```java
    new Integer(123);
    ```
* :bulb: **언박싱, Unboxing**
    - 참조형 -> 기본형
    - Wrapper클래스의 메소드를 이용한다
    ```java
    객체변수.intValue();
    ```
* :bulb: **오토 박싱, 오토 언박싱**
    - 박싱, 언박싱이 자동으로 이루어지는 현상
    - 기본형과 참조형을 따로 구분하지 않고 사용할 수 있다
    ```java
    	Integer iVal = new Integer(123); //참조형
		int num = 456; //기본형

		int sum = iVal + num; //연산에서도 구분없이 사용한다
    ```
* :bulb: **Wrapper클래스를 사용하는 이유**
    - 기본형은 자바 클래스들의 상속구조(계층)에 참여하지 못한다 -> 기본형은 Object클래스의 자식요소가 아니다
    - Wrapper클래스를 이용하여 기본형을 참조형으로 표현할 수 있게 된다
    - 기본형데이터들을 참조형으로 사용해야할 때 적용한다 (ex. 제네릭)

:bulb: **String 클래스**
- 패키지 : java.lang
- 문자열 표현하는 클래스
- 문자열의 데이터타입으로 사용된다
- 문자열을 다루는 기능(메소드)을 포함하고 있다
- 문자열 리터럴 상수도 String클래스 타입이다
```java
ex) "Apple" -> String타입
```
* :bulb: **문자열 객체 사용법**
    1. 리터럴 상수를 대입하여 사용하기
    ```java
	ex)	String str = "Banana";
    ```
    2. 객체를 생성하여 사용하기
    ```java
	ex)	String str = new String("Banana");
    ```
* :bulb: **String**
    - 문자열을 저장할 때마다 새로운 공간을 생성한다
    ```java
    String str = "Apple";
	str = "Banana";
	str = "Cherry";
    ```
    - 문자열 수정할 때에도 새로운 공간을 할당한다
    ```java
    String str = "Apple";
	str += "Banana";

	-> 기존의 "Apple"
	-> 추가될 "Banana"
	-> 합쳐진 "AppleBanana"
	-> 세가지 문자열이 각각 생성된다
    ```
    - 단순 문자열을 저장할 때 좋다
    - 문자열을 수정하면 성능이 좋지 않다
* :bulb: **StringBuffer, StringBuilder**
    - 객체 내부에 문자열을 저장하는 공간을 따로 생성한다
    - 이 공간을 지속적으로 관리한다
    - 공간의 크기(capacity)도 늘리거나 줄일 수 있다
    - 수정이나 삭제가 빈번한 문자열을 관리하기에 좋다
    - StringBuffer, StringBuilder는 동일한 기능을 가지고 있다
    - 메소드들도 다 같은 걸 가지고 있다
    - StringBuffer 동기화 처리되어있다 (Thread-Safe, 멀티스레드에 안전)
    - StringBuilder 동기화 처리되어있지 않다
	    - 멀티 스레딩 환경에서 선택하여 사용하게 된다
	    - 평소에는(싱글 스레딩) StringBuilder를 사용하면 된다
- 문자열을 저장하고 수정, 삭제가 없으면 String을 사용한다
- 문자열을 저장하고 수정, 삭제가 빈번하면 StringBuilder를 사용한다
- 문자열을 저장하고 수정, 삭제가 빈번하고
   멀티스레딩 환경이면 StringBuffer를 사용한다

* :bulb: **문자열 토큰으로 나누기**
    - String 클래스의 split() 메소드 이용하기
    - StringTokenizer 클래스 이용하기
	- 토큰, Token : 문자열을 특정 구분자를 이용해서 나눈 각각의 데이터
	- 구분자, Delimiter : 데이터를 구분하기 위해 사용되는 요소


:bulb: **자료 구조, Data Structure**
- 프로그램에서 사용되는 데이터들을 효과적으로 저장하고 관리하는 전략
- 프로그램의 알고리즘(동작원리)과 어울리는 형태로 데이터를 논리적으로 배치
```java
    학생 성적관리프로그램
    -> 2명의 학생
    -> 3과목
    int[][] score = new int[2][3];
```
* :bulb: **배열, Array**
    - 가장 기본적인 형태의 자료구조
    - 데이터를 일렬로 배치한 구조를 가진다 -> 선형 구조, Linear
* :bulb: **스택, Stack**
    - LIFO, Last Input First Output, 후입선출
    - 마지막(최근)에 입력된 데이터를 가장 먼저 사용한다
	- 메소드 Call Stack에서 사용되는 알고리즘이다
	    - Call Stack : 메소드의 호출 순서와 지역변수 공간의 관리
    - 자바에서 컬렉션의 Stack클래스를 통해 제공된다
    - 주요 메소드
        - push() : 데이터 입력
        - pop() : 데이터 출력 및 삭제
        - peek() : 데이터 확인, pop()될 데이터를 확인한다(삭제X)
* :bulb: **큐, Queue**
    - FIFO, First Input First Output, 선입선출
    - LILO, Last Input Last Output, 후입후출
    - 대기열 시스템을 구축할 때 사용한다
    - 주요 메소드
        - offer() : 데이터 입력, enqueue(인큐)
        - poll() : 데이터 출력 및 삭제, dequeue(디큐)
        - peek() : 데이터 확인, poll()될 데이터 확인(삭제X)

:bulb: **컬렉션, Collection**
- 자바에서 제공하는 기본 자료구조들을 모아놓은 것
- List, Set, Map 세가지 형태로 제공된다
* :bulb: **List 인터페이스**
    - 리스트 자료구조의 최상위 부모 인터페이스
    - 데이터를 일렬로 배치하는 자료구조 -> 선형구조
    - 요소(Element)들을 인덱스(index)로 관리한다
    - 배열은 생성되면서 요소를 저장할 수 있는 크기가 결정된다
    - 리스트는 요소가 추가될 때마다 저장공간을 확장되는 개념이다
    - 데이터를 리스트에 추가한 순서가 유지된다
    - 배열과 유사한 구조를 가진다
* :bulb: **interface List 의 구현체 (구현된 class)**
    - **class ArrayList, 단순 연결 리스트**
	    - 배열과 거의 같은 동작을 한다
	    - 배열과 달리 요소를 저장하는 개수가 확장 or 축소된다
	    - 단방향 포인터를 사용한다
	    - 단방향 포인터의 단점
	        - 중간데이터의 삭제, 중간데이터 삽입이 빈번할 경우 비효율적이다	
	    - 빠른 편이다 (배열에 비해서 크게 느리지 않다)
    - **class LinkedList, 양방향(이중) 연결 리스트**
	    - 양방향 포인터를 사용한다
	    - 양방향 포인터의 장점
	        - 중간데이터 삭제, 삽입에 잘 어울리는 구조이다
    - **class Vector**
	    - ArrayList와 같은 구조, 같은 사용법
	    - 동기화처리 되어있다(Thread-Safe)
* :bulb: **Set 인터페이스**
    - 비선형 구조
    - 집합
    - 데이터의 모음, 묶음
    - 데이터의 입력 순서를 유지하지 않는다
    - 인덱스가 없음
    - 중복데이터를 허용하지 않는다 (hashcode(), equals() 를 이용하여 중복검사한다)
* :bulb: **interface Set의 구현체(class)**
    - **class HashSet**
	    - 가장 기본이 되는 Set구현체
	    - 다른 Set클래스들에 비해서 접근이 빠른 편이다
    - **class LinkedHashSet**
	    - 데이터의 입력 순서를 유지한다
        - 인덱스는 없다
    - **class TreeSet**
	    - 정렬 기능이 포함된 Set
	    - 기본으로 오름차순정렬이다
        - Set 생성작업이 느린 편이다
	    - 데이터를 추가하거나 삭제하는 작업이 느린 편이다
        - 대신, 조회(탐색)이 매우 빠른 편이다
* :bulb: **매핑, Mapping**
    - 두 집합의 원소들 간의 대응관계
    - 데이터와 데이터사이의 관계
    - 일대일 매핑 (one to one, 1:1)
    - 일대다 매핑 (one to many, 1:m)
    - 다대일 매핑 (many to one, m:1)
    - 다대다 매핑 (many to many, m:n)
* :bulb: **Map 인터페이스**
    - 매핑된 데이터를 관리한다
    - Key, Value 두 데이터를 한 쌍(Entry)으로 묶어 데이터를 관리한다
    - 맵에는 여러 쌍의 데이터를 저장할 수 있다
    - Key는 데이터쌍(Entry)의 기준값으로 사용한다 (데이터의 식별값)
    - Value는 데이터쌍(Entry)의 Key에 대응하는 값 (매핑된 값, 데이터)
    - Key는 중복값 사용 불가
    - Value는 중복값 사용 가능
* :bulb: **interface Map의 구현체(class)**
    - **class HashMap**
	    - Map의 기본 동작을 구현한 클래스
	    - key중복검사에 hashCode()를 사용한다
	    - hashCode()가 같고 equals()가 true일 때 같은 키 값으로 판단한다
    - **class Hashtable**
	    - HashMap과 같다
	    - 동기화처리되어있다
    - **class Properties**
	    - Hashtable의 하위 클래스
        - 키(key)와 값(value)이 String으로 제한되어있다
	    - 주로 프로그램의 설정값을 저장하는 용도로 사용한다
	    - 옵션정보, DB연결 정보, 다국어 정보(Locale) 등으로 사용한다
	    - 키=값 쌍(entry)을 파일에 저장하고 불러올 수 있다
	    - 주로 확장자를 .properties로 다룬다

:bulb: **일반화 프로그래밍**
- 자료형을 일반화시켜 프로그래밍하는 것
```java
	int	===일반화==>	데이터타입 T
	double
	float
	boolean
	String
	Point
	Person
	...
```
- 자바에서는 제네릭(Generic)을 이용하여 일반화 프로그래밍이 구현된다
```java
ex)
public void print(int data) {
  System.out.println("데이터 : " + data);
}

public void print(double data) {
  System.out.println("데이터 : " + data);
}

public void print(Point data) {
  System.out.println("데이터 : " + data);
}

public void print(float data) {
  System.out.println("데이터 : " + data);
}

-> 같은 이름, 같은 동작을 하는 코드를 "데이터타입"만 다르게 여러 개 작성됨
---------------------------------

public <T> void print(T data) {
  System.out.println("데이터 : " + data);
}

-> 데이터타입을 일반화시켜 표현하고 중복으로 작성되는 코드를 줄인다
```
* :bulb: **제네릭, Generic**
    - 클래스 또는 메소드에서 사용되는 다양한 데이터타입을 일반화시켜 프로그래밍을하는 방법이다
    - 데이터타입만 달라지며 똑같은 코드(중복된 코드)를 작성해야하는 경우를 줄여준다
	    - 코드 재사용성이 높아진다
    - 타입 안정성이 제공한다
	    - 개발자가 원하는 데이터타입만 사용할 수 있도록 제한할 수 있다
	    - 다른 데이터타입을 사용하면 문법 에러가 발생한다
    - 특정 데이터타입으로 고정하여 사용하므로 불필요한 형변환이 줄어든다
* :bulb: **자주 볼 수있는 제네릭 문자**
    - T - Type
    - E - Element
    - K - Key
    - V - Value
    - N - Number
* :bulb: **제네릭 클래스**
    - 제네릭타입이 적용된 클래스
    ```java
    [접근제한자] class 클래스명<TYPE1, TYPE2, TYPE3, ...> {

	}
    ```
    - 제네릭 클래스를 이용하여 객체를 선언하고 생성할 때 타입 파라미터를 결정해주는 것이 좋다 -> 타입 파라미터를 명시하지 않으면 Object타입으로 자동 결정된다
* :bulb: **제네릭 메소드**
    - 메소드 내에서 사용할 수 있는 데이터타입을 일반화시켜 정의한다
    ```java
	[접근제한자] <TYPE1, TYPE2, ...> [리턴타입] 메소드명(매개변수) {

	}
    ```
    - 리턴타입, 매개변수타입, 지역변수타입으로 제네릭 사용 가능하다
    - 매소드를 호출하면서 타입파라미터를 결정할 수 있다 -> 전달인자 타입에 따라 자동으로 결정되도록 할 수 있다

:bulb: **프로그램의 개발 오류, 에러(Error)**
1. **컴파일 타임 에러, Compile-time Error**
    - 컴파일 시점에 발생하는 에러를 뜻한다 (이클립스에서는 소스코드를 저장하는 즉시)
    - 주로 문법 에러를 뜻한다(Syntax Error)
2. **런타임 에러, Runtime Error**
	- 프로그램 실행 도중 발생하는 에러
    - 수행할 수 없는 작업을 시도할 때 발생한다
3. **논리 에러, Logical Error**
	- 프로그램이 에러 발생없이 정상적으로 동작한다
    - 개발자가 의도한 대로 프로그램이 동작하지 않는 것을 뜻한다
    - ex) (의도하지않은) 무한 루프
* :bulb: **Throwable 클래스**
    - 런타임에러를 정의하고 있는 클래스들의 부모클래스
    - Error 클래스, Exception 클래스 들을 자식클래스로 가진다
* :bulb: **Error 클래스, 에러**
    - 심각한 수준의 오류
    - 복구가 안되는 수준의 문제 상황
    - 프로그램이 무조건 중단된다
    - 프로그램의 코드(자체적인 방법)로 해결할 수 없는 수준의 오류
    - ex) OutOfMemoryError -> 메모리가 부족한 상황에서 할당을 시도한 상황
* :bulb: **Exception 클래스, 예외**
    - 프로그램이 실행되는 동안 발생하는 예외적인 상황
    - 개발자가 예외 상황을 예측해서 프로그램 로직(코드)으로 처리 가능한 수준의 런타임 오류를 뜻한다
    - 논리적으로 예상 가능했던 상황이다 -> try-catch 구문을 이용하여 "예외 처리" 작업을 한다.
    - 예외 처리, Exception Handling : 발생할 수도 있는 예외적인 상황에 미리 대비하는 코드를 작성하는 것
* :bulb: **예외 처리 구문, Exception Handling**
    - try ~ catch 구문
    ```java
    try {

	  //예외가 발생할만한 코드

	} catch( Exception e ) { //발생할 예외 클래스로 적는 게 좋다

	  //예외 처리 코드 작성

	} finally {

	  //예외 발생 유무에 상관없이 무조건 실행되는 코드를 작성한다
	  //생략 가능한 블록

	}
    ```
* :bulb: **throw 키워드**
    - 개발자가 직접 예외를 발생(throw)시키기 위해 사용하는 키워드
    - 사용법
    ```java
    throw new 예외클래스();
    throw new NullPointerException();
    NullPointerException e = new NullPointerException();
    ---
	throw 예외객체;
    throw e;
    ```
* :bulb: **Checked Exception**
    - Exception의 하위클래스들 중에서 RuntimeException의 하위클래스들을 제외한 클래스들 ( Other Exceptions )
    - 반드시 예외처리구문(try-catch)을 사용해야한다
    - 예외처리코드를 적지 않으면 문법에러(컴파일타임에러)가 발생한다
        - quick fix : surround with try-catch
    - 실행단계가 아닌 코드 작성단계에서 미리 체크해서 예외처리구문을 작성해야 한다
* :bulb: **Unchecked Exception**
    - RuntimeException의 하위 클래스들
    - 반드시 예외처리하지 않아도 된다
    - 프로그램 실행 도중 발생한 예외를 확인한 후에 예외처리를 하게 된다
* :bulb: **throws 키워드**
    - 예외 처리 떠넘기기, 예외 처리 미루기
    - 예외가 발생한 메소드에서 자신이 예외를 처리하지 않고, 자신을 호출한 메소드에게 예외 처리를 미루는 키워드
    - 예외가 발생하는 상황에 대한 책임을 메소드를 호출한 쪽(Caller)에게 맡기는 방식
    - main()메소드에는 throws를 적용하지 않는 것이 좋다
    - 사용 방법
    ```java
	[접근제한자] [식별자] [리턴타입] 메소드명(매개변수) throws 예외클래스 {

	}
    ```
	- 메소드 정의코드에서 ()괄호 부분과 { 사이에 적어준다
* :bulb: **사용자 정의 예외 클래스 만들기**
    - API로 제공되는 예외클래스들 이외의 추가적인 예외 클래스를 작성할 수 있다
    - 예외 상황을 프로그램에 맞게 정의하고 클래스로 구현한 것
    - Exception클래스를 상속받아 구현할 수 있다 -> Checked Exception이 만들어진다
    - RuntimeException클래스를 상속받아 구현할 수 있다 -> Unchecked Exception이 만들어진다

:bulb: **입출력, Input/Output, I/O**
- 프로그램이 입출력장치와 데이터를 송/수신하는 것

:bulb: **스트림, Stream**
- 데이터의 통로, 데이터의 흐름
- 입출력 장치와 프로그램 사이에서 데이터를 통신(교환)할 수 있도록 제공되는 SW적인 장치
- 단방향이다
    - ( 입력스트림-->프로그램 )
    - ( 프로그램-->출력스트림 )
- FIFO구조로 되어있다 
- 기본적으로 바이트 단위로 통신한다
- 버퍼(Buffer)를 가지고 있다
    - 버퍼, Buffer : 데이터 임시 저장소
* :bulb: **스트림의 분류**
    1. 입출력 구분
        - 입력 스트림
        - 출력 스트림
    2. 연결 대상을 기준으로 구분
        - 1차 스트림 : 입출력장치와 직접 연결되는 스트림
        - 2차 스트림 : 1차스트림과 연결되어 추가(보조)기능을 제공하는 스트림
    3. 전송 데이터 형태에 따른 구분
        - 바이트 스트림 : 바이트(1B) 단위로 통신한다
        - 문자 스트림 : 문자(char, 2B) 단위로 통신한다
    4. 기능에 따른 구분
        - 보조 스트림 : 직접 입출력하는 기능이 없지만, 다른 스트림의 기능을 향상시킨다
* :bulb: **입력스트림의 기본 클래스(부모 클래스)** : class InputStream (java.io)
* :bulb: **출력스트림의 기본 클래스(부모 클래스)** : class OutputStream (java.io)
* :bulb: **InputStream의 read메소드**
```java
public int read(byte[] b) throws IOException
```
- 입력스트림에서 최대길이로 매개변수인 b배열의 길이(length)만큼 데이터를 읽어들인다
- 읽어들인 데이터를 매개변수로 전달한 b배열에 저장한다
- 읽어들인 데이터의 길이를 int형으로 반환된다
- 읽어들일 데이터가 없을 경우 -1 을 반환한다
    - 읽어들일 데이터가 없는 상황 == End Of Stream
    - EOF, End Of File == End Of Stream
* :bulb: **OutputStream의 write메소드**
```java
public void write(byte[] b, int off, int len) throws IOException
```
- b배열의 off인덱스부터 시작하여 len길이만큼 출력스트림으로 출력한다
- b배열의 데이터가 출력 버퍼에 전송(출력)된다
* :bulb: **보조스트림, FilterStream**
    - FilterInputStream : 바이트 입력스트림의 보조스트림 클래스
    - FilterOutputStream : 바이트 출력스트림의 보조스트림 클래스
* :bulb: **BufferedStream**
    - 클래스 내부에 버퍼를 가지고 있는 스트림
    - 입출력스트림의 입출력횟수(read(), write())를 줄여 성능 향상을 유도한다
    - 기본적으로 사용되는 보조스트림이다 -> 스트림을 다루면 거의 항상 사용한다
* :bulb: **DataStream**
    - 자바 기본자료형으로 형식을 유지하면서 입출력하도록 기능을 제공한다
    - 자료형에 맞는 입출력 메소드가 제공된다
* :bulb: **ObjectStream**
    - 객체 단위로 입출력할 수 있도록 기능을 제공한다
    - DataStream의 기능을 모두 사용할 수 있다
    - ArrayList같은 컬렉션도 객체형태를 유지하면서 입출력할 수 있다
    - 입출력에 사용되는 객체는 직렬화가능 클래스여야 한다 -> interface Serializable 상속
* :bulb: **직렬화, Serialization**
    - 크기가 큰 데이터(객체)를 바이트단위로 잘게 나누어서 스트림을 통과할 수 있도록 만드는 것
* :bulb: **역직렬화, Deserialization**
    - 바이트단위로 잘게 나누어져(직렬화되어) 스트림을 통과한 데이터를 원본의 형식(객체)으로 다시 합치는 것
* :bulb: **스트림의 종류**
```java
	    바이트 스트림               문자 스트림
	    ------------------------    ------------------------
(기본)  InputStream                 Reader
	    OutputStream                Writer

(성능)  BufferedInputStream         BufferedReader
        BufferedOutputStream        BufferedWriter

(파일)  FileInputStream             FileReader
        FileOutputStream            FileWriter
	    ------------------------	------------------------
        //바이트 스트림만 존재한다
(자료형) DataInputStream
        DataOutputStream

(객체)  ObjectInputStream
        ObjectOutputStream
	    ------------------------	------------------------
	    //바이트스트림을 문자스트림으로 변환한다
					                InputStreamReader
					                OutputStreamWriter
	    ------------------------	------------------------
	    //문자 출력 스트림의 기능을 강화해놓은 클래스
					                PrintStream
```

:bulb: **경로**
* :bulb: **절대 경로, Absolute Path**
    - 루트(root) 디렉토리로부터 파일까지의 모든 경로를 나타내는 방법
    - 루트 디렉토리 == 최상위 폴더
    - 윈도우OS는 "드라이브문자:\" 로 표현한다
    - 맥OS는 "/" 로 표현한다
    - ex) "D:\\Test\\folder\\file.txt"
    - ex) "E:/hi/hello"
    - ex) "/folder/file.txt"
* :bulb: **상대 경로, Relative Path**
    - 프로그램이 실행된 위치(경로)를 기준으로 파일의 위치를 상대적으로 표현한다
    - 클래스 패스, Class Path
	    - 프로그램이 실행된 위치(경로)
        - 이클립스로 프로그램을 실행할 경우 프로젝트 폴더를 클래스패스로 설정한다
* :bulb: **프로그램에서는 절대경로보다 상대경로를 사용하도록 한다**
    - 개발 환경과 실행 환경이 달라지면 절대 경로의 기준으로 지정한 위치가 존재하지 않을 수 있다
    - 완성된 프로그램이 배포되어 실행되는 환경에서 문제없이 동작해야 한다
    - 프로그램(프로젝트)의 내부를 기준으로 상대 경로를 지정하여 프로그램을 개발하도록 한다
* :bulb: **경로 지정 문자**
    - 상대 경로나 절대 경로를 표현할 때 사용하는 디렉토리 지정 문자
    ```java
        .	-> 현재 디렉토리
        ..	-> 부모 디렉토리
        /	-> 루트 디렉토리 (최상위 디렉토리)

        ex)	"D:/workspace/JavaBasic" 경로에서 작업 중일 경우
            -> "/test.txt"	    - "D:/test.txt"
            -> "./"			    - "D:/workspace/JavaBasic"
            -> "../"		    - "D:/workspace"
            -> "../././../"		- "D:/"
    ```

:bulb: **네트워크, Network**
- 노드(node)들의 연결망(통신망)
- 통신망에서의 노드 : 네트워크로 연결된 시스템들 -> 컴퓨터, 주변장치, 네트워크장비, 모바일기기, 스마트기기 등등
* :bulb: **노드의 구분**
    - 서버, Server : 다른 노드에게 서비스(기능)를 제공하는 노드
    - 클라이언트, Client : 서비스를 이용하는(제공받는) 노드 (역할에 따라 노드를 구분한다)
    - 전용 서버를 두는 방식을 CS방식이라고 한다
    - 각 노드가 서버, 클라이언트 역할의 구분이 없으면 P2P방식이라고 한다
* :bulb: **프로토콜, Protocol**
    - 통신 규약
    - 노드들이 통신(데이터 교환)할 때 지켜야할 규칙을 정해놓은 것
    - 통신 방식(절차), 전송하는 데이터의 형식, 노드의 위치(주소) 등을 정의한다
    - 대표적으로 TCP/IP Protocol 이 있다
* :bulb: **TCP/IP Protocol**
    - Transmission Control Protocol / Internet Protocol
    - TCP : 연결 제어 프로토콜 -> 통신 방식
    - IP : 노드 위치 프로토콜 -> 인터넷 주소(IP)
* :bulb: **TCP, 연결 제어 프로토콜**
    - 네트워크를 통해 전달되는 데이터를 작은 조각으로 나누거나 재조립하는 방식을 정하고 있다
    - 잘게 나눈 데이터 조각을 '패킷'이라고 한다
    - 한번에 큰 용량의 데이터를 전송하는 것이 현실적으로 부적절하므로 패킷단위로 잘게 나누어 전송한다 -> 통신망을 독점하게된다
    - 패킷마다 순서(번호)를 붙여 전송한다
    - 전송방식에 따라서 TCP방식, UDP방식으로 나눈다
* :bulb: **TCP vs UDP**
    - 패킷을 전송하는 방법(전략)이 다르다
    - TCP : 연결지향적, 신뢰성 있는 통신, 안정성↑
    - UDP : 비연결지향적, 신뢰성 없는 통신, 속도↑, 실시간 통신
	- 연결지향 : 송수신장치 사이에 연결이 먼저 수립된 후 데이터 통신
	- 비연결지향 : 연결없이 한쪽에서 다른 쪽으로 데이터 통신
* :bulb: **IP, Internet Protocol**
    - 인터넷 프로토콜
    - 노드의 위치를 표현하는 방법을 정의한 통신 규약
    - 패킷이 전송될 곳을 구분할 수 있게 해준다
    - 패킷마다 IP가 부여된다
* :bulb: **TCP/IP 프로토콜에서 사용하는 주소 체계**
    - **IP Address**
        - 네트워크 상에서 각 노드의 위치를 나타내는 주소 체계
	    - IP Protocol에 형식이 정의되어 있다
	    - 32bit DWORD타입으로 표현한다 (DWORD == 부호없는 정수 == 양수만 표현)
	    - 32bit를 1B단위로 4자리로 나눠서 표현한다
	    - 0~255.0~255.0~255.0~255
	    ```java
        ex)	192.168.10.3
		    win키 + r   (실행창)
		    cmd         (콘솔창)
		    ipconfig    (맥OS는 터미널에서 ifconfig)
        ```   
    - **Port Address(Number)**
        - 노드 안에서 서비스의 위치를 구분하는 주소
	    - 어떤 프로그램인지 구분하는 주소
	    - TCP Protocol에서 형태를 정의한다
	    - 16bit WORD타입으로 표현된다 (WORD == 부호없는 정수)
	    - 0~65535 내에서 정수값으로 사용된다
	    - IP주소 뒤에 : 을 붙이고 추가 적용해서 나타낸다
	    ```java
        ex)	192.168.10.3:8801
		    IP : 192.168.10.3
		    Port : 8801
        ```     
    - **Well-Known Port, 잘 알려진 포트번호**
        - 0번 ~ 1023번
	    - 자주 사용되는 서비스(기능)에 일반적으로 사용하는 포트번호
	    - 80 - 웹 서비스, HTTP
	    - 443 - 보안 웹 서비스, HTTPS
* :bulb: **소켓, Socket**
    - SW적으로 구현된 통신의 접속지점, 가상 장치
    - 자바에서는 클래스API로 제공된다
    - 통신에 필요한 절차를 프로그램에서 직접 구현하지 않고 바로 통신할 수 있도록 개발된 API
* :bulb: **소켓 클래스의 종류**
    - 서버용 소켓 : ServerSocket class
    - 클라이언트용 소켓 : Socket class