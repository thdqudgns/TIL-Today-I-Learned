# :pushpin: 기본 개념

#### :bulb: 자바 프로젝트, Java Project
- Java 프로그램 개발을 하기 위해 만드는 환경(폴더)
- 주로 하나의 프로그램을 개발하기 위해 프로젝트 1개를 생성하는 편이다

#### :bulb: 패키지, Package
- 프로그램을 구성하고 있는 코드들을 모아놓는 폴더(꾸러미)
- 비슷한 기능이나 하나의 기능을 구현할 때 필요한 소스코드들을 모아놓는다
- 자바 프로젝트에는 반드시 1개 이상의 패키지로 구성한다

#### :bulb: **소스 코드, Source Code**
- 프로그램을 개발하기 위해 작성된 코드   
	**Source**: 원시의, 원본, 출처   
	**Source Code**: 프로그램의 원본이 되는 코드
- 자바에서는 클래스(Class) 단위로 소스코드를 작성한다
- 자바 클래스파일의 확장자는 ".java" 로 가진다

#### :bulb: 자바 프로그램 개발(실행) 과정
    ```java
    소스코드 작성 --컴파일--> 바이트코드  --실행--> JVM
	   .java     --compile--> .class    --run--> JVM
	(Source Code)   ---->   (Byte Code)   ---->  (Java Virtual Machine)
    ```
- 고급언어(Java코드)를 저급언어(바이트코드)로 번역하는 과정을 컴파일(Compile)이라고 한다
- 컴파일러(Compiler)가 컴파일을 수행한다
- 이클립스에서는 소스코드를 저장하면 자동으로 컴파일된다
- 컴파일이 수행될 땐 소스코드에 대한 문법 검사도 같이 이루어진다. **자바 컴파일러**: javac.exe
- 프로그램을 실행하면 JVM이 바이트코드를 읽어 실행한다. **실행 프로그램**: java.exe
- **고급 언어(High Level)** -> **사람**이 이해하기 쉬운 형태의 프로그래밍 언어
- **저급 언어(Low Level)** -> **컴퓨터**가 이해하기 쉬운 형태의 프로그래밍 언어

#### :bulb: 컴파일러, Compiler (compile)
- 코드를 실행하기 전에 미리 번역해놓는 방식
- 사전에 번역하는 시간이 많이 필요하다
- 실행하는 동안에는 따로 번역할 필요가 없어 빠른 반응성을 보인다

#### :bulb: 인터프리터, Interpreter (interpret)
- 코드를 미리 번역해놓지 않고 실행할 때 필요한 부분을 번역하여 실행하는 방식
- 사전 번역 시간이 필요없다, 곧바로 실행 가능
- 특정 기능을 실행할 때마다 번역할 시간이 필요해서 반응이 느린 편이다

#### :bulb: JIT 컴파일, Just-In-Time Compiler
- 인터프리터 기반으로 동작한다
- 한번 번역한 코드는 캐시(cache, 임시저장소)에 저장해놓고 사용한다
- 인터프리트의 실행속도(반응성)가 느린 점을 보완한 방식
- JVM은 JIT컴파일 방식으로 바이트코드를 실행한다

#### :bulb: 자료형, Data Type
- 데이터를 표현하는 정해진 방식
- 데이터 표현법(규칙)
- 프로그램에서 사용하는 데이터를 표현하는 방법이다

#### :bulb: 자바의 기본 데이터타입
- 자바에서 데이터를 표현하는 8가지 방식
- 정수형 타입 (소수점 이하를 표현하지 않는 숫자 형식)   
	1 byte (1Byte) -128 ~ 127   
	2 short (2Bytes) -32768 ~ 32767   
	3 **int** (4Bytes) 약 -21억 ~ 약 21억 => **(정수형 기본 데이터타입)**   
	4 long (8Bytes)	약 -900경 ~ 약 900경
- 실수형 타입 (소수점 이하를 표현하는 숫자 형식)   
    5 float (4Bytes)   
	6 **double** (8Bytes) => **(실수형 기본 데이터타입)**
- 논리형 타입   
	7 **boolean** (1Byte) true/false => **(논리형 기본 데이터타입)**   
    (true:참, false:거짓)
- 문자형 타입   
	8 **char** (2Bytes) => **(문자형 기본 데이터타입)**   
	- 문자형은 컴퓨터에서 정수형 타입으로 처리된다.
    - 코드화 시킨 문자체계(매핑표)를 적용해서 인식/사용한다.
    - 자바는 유니코드(Unicode)를 사용한다.

#### ASCII코드 American Standard Code for Information Interchange
- 영어 대소문자, 숫자, 특수기호, 가상키를 1:1로 매핑(mapping)한 표   
- 한글 없음

#### 유니코드 Unicode
- ASCII로만 표현할 수 없는 전세계 문자를 매핑한 표   
- 유니코드는 변환과정(인코딩)을 거쳐 사용한다   
- 한글 인코딩 방식은 UTF-8, EUC-KR, CP949(MS949)   
- 주로 UTF-8을 사용한다

#### :bulb: 데이터 형 변환, Data Type Casting
- 데이터의 타입을 일시적으로 다른 타입으로 변환하는 것
- 연산은 피연산자들의 데이터타입이 같아야 수행 가능하다
- 서로 다른 데이터타입의 피연산자를 연산하려면 형변환이 필요하다 -> 형변환을 통해 데이터타입을 일치시킨 이후에 연산할 수 있다
- **자동 형변환(묵시적, 암시적, 암묵적)**
    - 표현범위가 작은 데이터를 큰 데이터로 사용할 때
         ```java
        11 + 34.56	( int + double )
		-> 11.0 + 34.56	( double + double, 자동 형변환 )
		-> 45.56	( double )
        ```
- **강제 형변환(명시적)**
    - 표현범위가 큰 데이터를 작은 데이터로 사용할 때
    - 형변환 연산자를 사용한다
    - 데이터 또는 변수 앞에 (type) 형식으로 적어준다
         ```java
        11 + (int)34.56	( int + (int)double )
		-> 11 + 34	( int + int )
		-> 45		( int )
        ```
- **자바 자료형의 표현범위 비교**
    ```java
    byte < short < int < long < float < double   
	        char < int
    ```
    - boolean은 표현범위를 비교할 수 없음 (형변환 안됨)

#### :bulb: 변수, Variables
- 변하는 값
- 데이터(값)를 저장하는 메모리의 공간
- 데이터를 저장하는 그릇
- 저장할 수 있는 데이터의 형식을 자료형으로 지정하여 생성한다
- 변수 공간에는 한 순간에 하나의 데이터만 저장할 수 있다
- 저장된 데이터는 계속 변경할 수 있다
- **변수 선언(Declaration)**
    - 프로그램에서 사용하려는 변수를 생성하는 코드
    - 자료형을 명시해서 변수를 선언한다   
  	[자료형] [변수명];   
    ```java
    int num;
    ```
    - 각 자료형에 대입하는 기본값
        - 정수 0
        - 실수 0.0
        - 논리 false
        - 문자 \0 (null문자)
- **변수 대입(Assignment)**
    - 생성된 변수공간에 데이터를 저장하는 것
    - 자료형에 맞는 데이터를 저장해야한다   
    [변수명] = [데이터];   
    //오른쪽의 데이터를 왼쪽의 변수공간에 저장한다   
    ```java
    num = 14;
    ```
- **변수의 선언과 동시에 초기화(Initialization)**
    - 변수를 생성하면서 대입을 한번에 처리하는 것   
  	[자료형] [변수명] = [데이터];   
    ```java
    int data = 555;
    ```
    - 쓰레기값이 변수에 저장되는 것을 방지하고 변수의 값을 초기화한다
    - **쓰레기값, Garbage Value**   
        - 메모리공간은 사용이 끝난 후 별도로 지우지 않는다. 사용이 종료 되어도 이전 데이터흔적이 남아있게 된다.
        - 새로운 변수를 선언하면 메모리의 적당한 공간을 사용하게 되고, 이전 데이터흔적이 남아있을 수 있다.   
        -> 어떤 값이 들어있는 지 알 수 없는 상태   
        -> 자바에서는 쓰레기값을 활용할 수 없도록 에러(Error)로 처리한다
- **변수 명명 규칙(선언 규칙, 네이밍 규칙)**
    - 영어 대문자, 소문자, 숫자만 허용한다
    - 특수기호는 _ 와 $ 만 허용한다
    - 대소문자를 구분한다 ( A 와 a 다른 이름 )
    - 숫자로 시작하면 안된다
    - 띄어쓰기 금지
    - 변수명과 패키지명과 메소드명은 소문자로 시작한다
    - 클래스명은 대문자로 시작한다

#### :bulb: 상수, Constant Number
- 변하지 않는 값
- 데이터의 값 자체를 뜻한다
- 자료형을 가지고 있음
    ```java
        123	- int형 상수
		12.34	- double형 상수
		'Y'	- char형 상수
		true	- boolean형 상수
	    654L	- long형 상수(정수값 뒤에 L 붙여 사용)
		3.14f	- float형 상수(실수값 뒤에 f 붙여 사용)
    ```
- **상수의 종류**
    - **리터럴(Literal) 상수** : 상수 그 자체를 뜻한다
    - **이름있는 상수** : 변수를 상수화시켜 사용한다
    	- 변수를 만들고 값을 변경할 수 없도록 강제한 것
        - final키워드를 적용시켜 사용한다
        - 이름있는 상수의 이름은 모든 글자를 대문자로 작성한다
        - 단어의 구분은 Snake Case로 한다( _ 이용)

#### :bulb: **연산, Operation, Operate**
- 프로그램의 작동
- 컴퓨터의 모든 작동
- **연산자, Operator**
    - 연산을 기호로 나타낸 것이다
- **피연산자, Operand**
    - 연산의 대상(값, 상수, 변수 등)
- **연산자를 구분하는 기준**
    - 피연산자의 개수
        - 단항연산자, Unary Operator
	    - 이항연산자, Binary Operator
	    - 삼항연산자, Ternary Operator
    - 연산의 기능에 따른 분류
        - 산술 연산자 (+, -, *, /, %)
	    - 관계 연산자 (>, <, >=, <=, ==, ===, !=)
	    - 논리 연산자 (&&, ||, !)
	    - 대입 연산자 (=, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=, >>>=)
	    - 비트 연산자 (<<, >>, >>>, &, |, ^, ~)
	    - 기타 연산자 (참조 . , 형변환 (type), 삼항 (조건식)? (참):(거짓) )

#### :bulb: **공백문자, White Space**
    ```java
	SP, SPace
    - 띄어쓰기		' ' (ASCII 32)
	
    LF, Line Feed, New Line
    - 개행, 줄바꿈	'\n' (ASCII 10)
	
    HT, Horizontal Tab
    - 탭, 수평탭	'\t' (ASCII 9)

	** 개행(줄바꿈)은 운영체제에 따라 '\r' 과 '\n'을 조합해서 사용한다
    ('\r' - CR, Carriage Return, '\n' - New Line)
    *Carriage Return: 맨 첫 칸으로 커서를 이동시킨다.
	*New Line: 다음줄로 커서를 이동시킨다.

	윈도우 : '\r''\n' 두 문자를 합쳐서 사용함
	리눅스 : '\n'
	맥OS : '\r' 이었는데 요즘엔 '\n'

    *Form: 종이
	*Feed: 먹이 - 종이를 먹는다. 종이가 타자기 안으로 들어감. Page Down과 같은 것
	*Line Feed: 줄 먹이기, 한 줄을 먹인다.
    ```

#### :bulb: **데이터 입출력**
- **키보드 = 표준입력, Standard Input (Stdin)** -> 키보드가 없으면 컴퓨터가 실행되지 않기도 한다.
- Java에서는 Stdin을 **System.in** 으로 표현한다. Java에서 키보드의 입력을 받아들이는 API가 System.in이다. 프로그램의 **입력스트림**을 통해서 입력.
- 입력의 기본이 키보드였다면, 출력의 기본은 모니터다. **모니터 = 표준출력, Standard Output (Stdout)**
- Java에서는 Stdout을 **System.out** 으로 표현한다. Java에서 모니터로 출력하는 API가 System.out이다. 프로그램의 **출력스트림**을 통해서 출력. (스트림은 SW 프로그램이다)
- System.in과 System.out을 합쳐 **System.io**라고 부른다.
- 프로그램 내에서는 빠르게 작동하지만, 스트림을 통해 장치를 오갈 때 장치는 느리게 반응한다. 그래서 입출력은 굉장히 느리다. **이것을 보완하기 위해 임시저장소 Buffer를 만들어 여기에 출력사항을 기록한다.** 그리고 프로그램은 다른 일을 시작한다. 모니터는 Buffer에서 조금씩 가져와 일을 한다. 그러면 **프로그램과 모니터의 작업이 구분된다.** 프로그램은 Buffer에 데이터를 저장시키고 다른 일을 하게 되고, 모니터는 자신의 속도에 맞게 작업을 처리할 수 있다.
    ```java
	키보드 ---(입력스트림)---> 프로그램 ---(출력스트림)---> 모니터
	// 입력스트림, 출력스트림에 Buffer 있다.
    ```
- 이번엔 입력 Buffer를 생각해보자. 초기 콘솔 입력 창에 "123\n" 을 입력했다고 치자. nextInt는 입력 Buffer 안에 있는 정수를 찾아서 프로그램으로 가져오는 기능을한다. **(123만 가져옴)** 프로그램으로 가져온 데이터는 Buffer에서 지운다.
- nextLine은 입력 Buffer 안에 있는 개행문자'\n' 전까지의 데이터와 개행문자'\n'을 프로그램으로 가져온다. 그런데 입력 Buffer 안에는 123이 지워지고 현재 **'\n' 밖에 남지 않았다.** 그래서 뭔가를 입력할 새도 없이 **'\n'을 인식하여 바로 다음 출력될 문자열이 출력된다.**
- 이것을 해결하기 위해서는 **남아있는 '\n'을 지워줘야 한다.** 그래서 중간에 **sc.nextLine();**을 넣어주면 된다. (sc는 변수명) 이것이 남아있는 '\n'을 가져갈 것이다.
    ```java
    ** 버퍼에서 해당 데이터타입의 자료만 가져가는 기능들 (개행문자 \n 은 남긴다)
    next()
    nextInt()
    nextDouble()
    nextBoolean()
    nextByte()
    nextShort()
    nextLong()
    nextFloat()

    ** nextLine()은 문자열을 가져가고 개행문자를 지워준다 

    이런 차이로 버퍼이슈가 생긴다.
    ```
    
    ```java
    Scanner sc = new Scanner(System.in);
    //스캐너 클래스의 객체 sc는 참조형이다.
    ```
- 변수 sc를 선언하면 변수 공간A가 생성된다. 그 공간A에는 값이 저장되진 않고, 값을 지니고 있는 또 다른 공간B의 **주소**가 있다. 
- 키보드를 통해 입력된 값이 공간B에 저장된다. 변수를 활용하면 변수에 저장된 **주소**를 읽고, 공간 B에 입력된 값을 가져온다.

#### :bulb: **제어문, Control Statement**
- 프로그램의 기본 진행 흐름(**위->아래**)을 변경(제어)하는 구문
    ```java
	** 프로그램의 기본 진행 : 메인 메소드에서 시작하여 코드를 한 줄씩 순서대로 전부 실행하는 것

	ex)	**프로그램의 메뉴
		
		1. 새로 만들기
		2. 옵션
		3. 끝내기

		선택: _ 
		
		(Java는 클릭이 아니라 명령프롬프트와 같은 콘솔창에서 진행된다)
    ```
- 조건에 따라 **프로그램의 진행흐름을 바꾸는 것**이 제어문이다. 개발자가 원하는 흐름으로 프로그램을 제어할 수 있게 된다.
- **제어문의 종류**
    - **조건문, condition** : if, else, else if
    - **반복문, loop** : for, while, do-while
            ```java
            for문에서 조건식을 작성할 때,
            초기식은 0으로 사용하는 것이 일반적이고 
            조건식은 되도록 등호 없이 하는 것이 좋다. 
            (>= or <= 가 아니라 > or <으로)
            ```

            ```java
            for문 중첩으로 별찍기를 해보니, 알게 된 것이 있다. 
            for문의 정수형 변수 i,j을 단순히 행과 열로 보기보다, 
            조건식을 통해 찾아야 하는 반복횟수로 보는 것이다.

            i가 몇일 때 j가 얼만큼 반복되어 가로로 이어지는지, (개행은 ln으로 해결)
            
            - 초기식의 시작은 0으로 설정
            - 조건식의 부등호는 등호가 없이 초과, 미만으로만 설정
            - i의 조건식은 행을 보고 정하고,
            - j의 조건식은 반복 횟수를 보고 정하는 것이다.
            ``` 
    - **선택문, selection (조건문에 포함됨)** : switch
    - **기타 제어문** : break, continue

#### :bulb: **배열, array**
- 같은 자료형의 여러 변수를 하나의 묶음으로 사용하는 것
- 여러개의 변수를 한 번에 선언(생성)할 수 있다
- 선언되는 변수들의 이름을 고민하는 노력이 줄어든다
- 한꺼번에 선언된 변수 공간들을 인덱스(index)를 이용하여 관리한다
- **배열의 선언 ( arr = 주소공간 )**
    - 배열 공간에 대한 참조값을 저장할 수 있는 변수 선언
        ```java
        데이터타입[] 배열명;
        ex) int[] arr; //추천
            char[] chArr;
            double[] dbArr;

        데이터타입 배열명[];
        ex)	int arr[]; //비추천
            char chArr[];
            double dbArr[];
        ```
- **배열 생성 ( arr[0] = 데이터공간 )**
    - 실제로 데이터를 저장할 수 있는 변수공간(요소, Element)을 생성한다
        ```java
       	new 데이터타입[개수]

        ex) int[] arr; //배열 변수 선언
            arr = new int[10]; //배열 생성
            
        ** 배열의 크기(길이)(size, length)는 양수로 지정해야만 한다 ">=1"
        음수로하면 에러난다 negative size
        ```
- **배열의 요소 접근(활용)**
    - 일반 변수처럼 사용하면 되고, index 번호까지 명시해줘야 한다
    - 배열의 인덱스(index)를 이용하여 요소(Element, 구성요소, 저장공간)에 접근한다
    - 인덱스는 0부터 시작하여 1씩 증가한다. (for반복문도 0부터 시작하게 했다. 비슷하다. 그래서 배열과 반복문을 조합해서 사용하는 경우가 많다)
    - 인덱스로 음수를 사용할 수 없다
    - 배열의 크기를 벗어난 인덱스를 사용할 수 없다
        ```java
        ex) new int[10];
		    0~9의 인덱스를 가진다
		    -> 0~'lenght-1' 만큼만 사용가능하다
        ```
#### :bulb: **플래그, flag**
- 깃발이라는 뜻
- 특정 상황이나 상태 등을 기억하기 위해서 사용한다
- 다른 프로그램이나 다른 로직에 신호를 보내기(남기기) 위해 사용하는 값(변수)
- programming에서는 주로 boolean변수를 사용한다 (+ int도 사용한다. 상황이 3가지 보다 많을 때)
    ```java
    ex)	boolean isPositive = false; //플래그
	
		if (num>0) {
		  isPositive = true;
		}

		if(isPositive){
		  System.out.println("양수입니다");
		}else {
		  System.out.println("양수가 아닙니다");
		}
    ```
- 프로그램의 로직이 끝나는 시점과 결과값이 나오는 시점이 다를 때 사용하면 편하다
- 로직을 처리하는 도중 결과값이 나오지만, 결과값에 상관없이 끝까지 실행되어야 하는 경우 결과값을 플래그로 저장해 놓는다

---