# :pushpin: 정렬, Sort
주어진 숫자를 순서대로 나열하는 것.

### :bulb: 버블 정렬, Bubble Sort
- 오른쪽부터 왼쪽으로 **인접한 두 개의 숫자를 비교해서 교환하는 작업**을 반복한다. **작은 수가 왼쪽으로 가도록**
- 1라운드를 거칠 때마다 가장 작은 숫자가 왼쪽 끝으로 이동한다. = **수열 중에서 가장 작은 숫자가 왼쪽 끝으로 이동할 때까지 교체하는게 한 라운드다.**
- 그럼 2라운드에서는 왼쪽 끝을 제외하고, 왼쪽 끝에서 두 번째에 도착할 때까지 앞의 작업을 반복한다.
- 버블정렬은 1라운드에서 n-1회, 2라운드에서 n-2회, n-1라운드에서 1회를 비교한다. 양 끝을 합치면 (n-1) + 1 = n 이고 라운드는 절반으로 줄어들므로 **비교횟수는 n x n/2가 된다.**
- 따라서 버블정렬의 계산 시간은 **O(n²)** 이 된다.

### :bulb: 선택 정렬, Selection Sort
- **수열 중에서 선형탐색으로 최솟값을 검색해서 왼쪽 끝에 있는 숫자와 교체하는 작업을 반복한다.**
- **선형탐색을 하고, 맨 왼쪽과 숫자를 바꾸는 것이 한 라운드다.**
- 2라운드에서는 왼쪽 끝에서 두 번째에 있는 숫자와 교체한다. 즉, 남은 숫자 중에서 왼쪽 끝에 있는 숫자와 교체하는 것이다.
- 최솟값이 이미 왼쪽 끝에 위치한 경우에는 아무런 작업을 하지 않는다.
- 선형탐색으로 최솟값을 검색한 이후에는 왼쪽 끝과 바로 교체하기에, **선택정렬은 선형탐색 시간이 알고리즘 계산 시간이다.**
- 선형탐색을 위해 1라운드에서 n-1회, 2라운드에서 n-2회, n-1라운드에서 1회 비교를 한다. 따라서 버블정렬과 같은 **O(n²)** 의 계산시간이 걸린다.

### :bulb: 삽입 정렬, Insertion Sort
- 수열의 **왼쪽부터 순서대로 정렬**하는 방식이다.
- 처음에는 왼쪽 끝의 숫자를 정렬이 끝났다고 간주한다. 이것으로 1라운드가 종료된다.
- 계속해서 **아직 작업하지 않은(미탐색 영역) 숫자 중에서 왼쪽 끝에 있는 숫자를 꺼내서 왼쪽에 있는 정렬이 끝난 숫자와 비교한다.** 왼쪽의 숫자가 크면 위치를 바꾼다. 이 작업을 자신보다 작은 숫자가 나타나거나 왼쪽 끝에 도착할 때까지 반복한다. 그렇게 **교체가 멈추면 한 라운드가 끝난다.**
- 미탐색 영역의 숫자를 꺼내서 정렬시킬 때, 정렬 완료된 숫자와 대소비교하고 교체작업을 한다. **k라운드에서는 최대 k-1회까지 작업한다.** 2라운드에서 1회, 3라운드에서 2회, n라운드에서 n-1회의 비교와 교체가 발생한다. 계산시간이 버블정렬, 선택정렬과 같이 **O(n²)** 가 된다.

### :bulb: 힙 정렬, Heap Sort
- **[힙](https://github.com/thdqudgns/TIL-Today-I-Learned/blob/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md#bulb-%ED%9E%99-heap)이라는 데이터 구조를 사용한다.**
- 처음에는 힙에 **내림차순**으로 숫자를 저장한다.
- **내림차순 힙은 큰 것부터 순서대로 데이터를 추출하는 성질이 있으므로 꺼낸 숫자를 오른쪽부터 역순으로 나열하면 정렬이 완료된다.**
- **숫자를 하나 꺼낼 때마다 힙을 재구축한다.** (마지막 노드(맨밑의 맨우측)를 최상단으로 옮기고, 비교하여 아래로 내리는 식으로)
- 숫자를 꺼내는 것과 힙을 재구축하는 것을 반복한다. 모든 숫자를 힙에서 꺼내면 정렬이 완료된다.
- **힙 정렬을 위해 n개의 숫자를 힙에 저장할 때 걸리는 시간은 O(n log n)이 된다.(숫자 하나 추가에 걸리는 시간 'log n' x 숫자의 개수 'n')** 빈 상태에서 데이터를 하나씩 추가하면 되지만, 힙의 높이가 log₂n 이하이므로 1회 추가에 O(log n)의 시간이 걸리기 때문이다. 또한, 각 라운드에서 최대 숫자를 꺼내서 힙을 재구축하는 데 걸리는 시간은 O(log n)이다. **라운드 수는 n이므로 힙이 완성된 후에 정렬하는 시간도 O(n log n)이 된다.(재구축 시간 'log n' x 라운드 수 'n')** 따라서 힙 정렬의 계산 시간은 전체적으로 O(n log n)이 된다.
- 이것은 버블정렬, 선택정렬, 삽입정렬의 계산시간에 비해 빠른 속도다. 그러나 힙이라는 복잡한 데이터 구조를 구현하는 것이 어렵다.

### :bulb: 병합 정렬, Merge Sort
- 정렬하고 싶은 수열을 두 개의 수열로 분할한다. 더 이상 분할되지 않는 상태에 이르면 그룹들을 병합한다.
- **병합할 때에는 병합 후의 그룹 내에서 숫자가 작은 순으로 나열되도록 한다.**
- 병합정렬에서 숫자를 분할해 갈 때는 계산 시간이 걸리지 않는다. 처음부터 분할된 상태라고 생각해도 좋다.
- 두 개의 정렬이 끝난 수열을 병합하는 부분은, 선두의 수를 비교해서 작은 쪽을 위로 올리는 것을 반복하는 것이 전부이므로 두 수열의 길이에 따라 달라진다. 따라서 **하나의 층에서 병합 계산 시간은 그 층에 있는 숫자의 수가 된다.**
- **어떤 층을 봐도 숫자는 n개 이므로 각 층의 계산 시간은 O(n)이 된다.**
- n개의 숫자를 하나가 될 때까지 반씩 분할했을 때의 층수는 log₂n이 되므로 **층수는 전부 log₂n층이 된다.**
- 즉 전체 **계산 시간은 O(n log n)이 된다.** 힙 정렬과 같은 시간이다.

### :bulb: 퀵 정렬, Quick Sort
- **기준이 되는 수(피봇, pivot)를 수열 안에서 임의로 하나를 선택한다. 그리고 피봇 이외의 수를 '피봇보다 작은 수'와 '피봇 이상인 수'의 두 그룹으로 나누고 '피봇보다 작은 수 < 피봇 < 피봇보다 큰 수' 순서로 배치한다. 그 후 또다시 각 그룹을 퀵 정렬로 정렬하면 된다.**
- 이렇게 알고리즘의 내부에 알고리즘 자신을 적용시키는 것을 '재귀(recursive)'라고 한다.
- 계산 시간은 평균적으로 **O(n log n)** 이 된다. 매번 최솟값이 피봇으로 선택되면 **O(n²)** 이 된다.

---
# :pushpin: 배열 탐색

### :bulb: 선형 탐색
- 배열에서 데이터를 탐색하는 알고리즘
- 데이터가 정렬되어 있지 않아도 적용할 수 있다
- **선두에서부터 순서대로 비교를 반복해 간다**
- 데이터 수가 많고, 대상 데이터가 뒤에 있는 경우, 대상 데이터가 존재하지 않는 경우에는 비교 횟수가 많아져서 시간이 걸린다
- 데이터 수를 n이라고 하면 계산 시간은 **O(n)** 이 된다

### :bulb: 이진 탐색
- 배열에서 데이터를 탐색하는 알고리즘
- 데이터가 정렬된 경우에만 적용할 수 있다
- **배열의 중앙에 있는 데이터와 대상 데이터를 비교하여 왼쪽과 오른쪽을 판단하고, 필요가 없어진 쪽은 버린다**
- 정렬되어 있다는 것을 활용하여 탐색 범위를 매번 반씩 줄여나갈 수 있다
- 탐색할 범위가 한 개의 데이터가 되면 종료
- 매번 반으로 나누므로 계산시간은 **O(log n)** 이다.

---
# :pushpin: 그래프 탐색
- **그래프** : 몇 개의 정점이 간선으로 연결된 것
- **가중 그래프** : 간선에 가중치가 추가된 것, **연결의 정도**를 표현할 수 있다   
> ex) 네트워크 그래프, 지하철 노선도
- **방향성 그래프** : 간선에 방향을 부여한 것   
> ex) 웹 페이지의 링크 이동

### :bulb: 그래프 사용의 장점
- 가중치 그래프를 통해 가중치의 합이 최소인 경로를 찾을 수 있다   
> 통신 시간이 짧은 네트워크 경로, 이동시간이 짧은 노선도

### :bulb: 너비 우선 탐색
### :bulb: 깊이 우선 탐색
### :bulb: 벨먼-포드 알고리즘
### :bulb: 다익스트라 알고리즘
### :bulb: A*
