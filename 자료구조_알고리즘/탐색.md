# :pushpin: 배열 탐색

### :bulb: 선형 탐색
- 배열에서 데이터를 탐색하는 알고리즘
- 데이터가 정렬되어 있지 않아도 적용할 수 있다
- **선두에서부터 순서대로 비교를 반복해 간다**
- 데이터 수가 많고, 대상 데이터가 뒤에 있는 경우, 대상 데이터가 존재하지 않는 경우에는 비교 횟수가 많아져서 시간이 걸린다
- 데이터 수를 n이라고 하면 계산 시간은 **O(n)** 이 된다

### :bulb: 이진 탐색
- 배열에서 데이터를 탐색하는 알고리즘
- 데이터가 정렬된 경우에만 적용할 수 있다
- **배열의 중앙에 있는 데이터와 대상 데이터를 비교하여 왼쪽과 오른쪽을 판단하고, 필요가 없어진 쪽은 버린다**
- 정렬되어 있다는 것을 활용하여 탐색 범위를 매번 반씩 줄여나갈 수 있다
- 탐색할 범위가 한 개의 데이터가 되면 종료
- 매번 반으로 나누므로 계산시간은 **O(log n)** 이다.

---

# :pushpin: 그래프 탐색
- **그래프** : 몇 개의 정점이 간선으로 연결된 것
- **가중 그래프** : 간선에 가중치가 추가된 것, **연결의 정도**를 표현할 수 있다   
    > ex) 네트워크 그래프, 지하철 노선도
- **방향성 그래프** : 간선에 방향을 부여한 것   
    > ex) 웹 페이지의 링크 이동
- **그래프 사용의 장점**
    - 가중치 그래프를 통해 가중치의 합이 최소인 경로를 찾을 수 있다   
        > ex) 통신 시간이 짧은 네트워크 경로, 이동시간이 짧은 노선도

### :bulb: 너비 우선 탐색
- 시작점에 가까운 정점부터 탐색하는 방식
- 한 정점에서 도달할 수 있는 정점들이 다음 이동 대상 후보가 된다
- 후보들 중에서 하나의 정점을 선택한다. 선택 기준은 가장 먼저 추가된 것(선입선출->"큐" 이용 가능)
- 간선을 뛰어넘으면서 후보에 추가된 순서대로 탐색한다
![너비 우선 탐색](https://i.imgur.com/UmhUpnb.jpg)

### :bulb: 깊이 우선 탐색
- 하나의 길을 끝까지 따라가며, 더 이상 진행할 수 없는 곳에 다다르면 다음 후보가 되는 길을 따라간다
- 다음 정점의 선택기준은 가장 늦게 추가된 정점이다. 같은 시점에 후보가 된 것은 어느 것을 선택하든 상관없다(후입선출->"스택" 이용 가능)
![깊이 우선 탐색](https://i.imgur.com/aZJecix.jpg)

### :bulb: 벨먼-포드 알고리즘
- 간선에 가중치가 부여된 가중 그래프로 **최단 경로 문제**를 해결하기 위한 알고리즘이다
    1. 각 정점의 초기 가중치를 설정한다. 시작점은 0, 그 외의 정점은 무한대(∞)로. 이 값이 작아지면서 올바른 값으로 수렴하게 된다
    2. 간선을 선택하고 정점간 이동하기 위한 가중치를 계산한다. **'가중치 = 시작 정점의 가중치 + 간선의 가중치'**
    3. **계산한 결과가 현재 정점의 값보다 작으면 가중치를 그 새로운 결과값으로 변경한다**
    4. 모든 간선에 적용한다. 그럼 1라운드가 끝난다. 같은 작업을 가중치가 변경되지 않을 때까지 반복한다
    5. 가중치의 합이 최소인 최단 경로가 나온다
- 계산 시간
    1. 정점 수를 n, 간선 수를 m이라고 한다
    2. 이 알고리즘은 가중치 변경 작업을 n회 순회하면 마무리된다
    3. 1라운드의 변경 작업에서는 각 간선을 1회씩 조사하므로 1라운드에 걸리는 계산 시간은 O(m)이 된다
    4. 따라서 전체 계산 시간은 **O(nm)** 이다    
- 간선의 가중치가 **음수**라도 알고리즘이 동작하지만, 그 간선이 폐로인 경우에는 계속 가중치가 작아지므로 **'최단 경로가 존재하지 않는다'** 는 판단을 할 수 있다

### :bulb: 다익스트라 알고리즘
- 벨먼-포드 알고리즘 처럼 그래프의 최단 경로 문제를 해결하기 위한 알고리즘이다
    1. 각 정점의 초기 가중치를 설정한다. 시작점은 0, 그 외의 정점은 무한대(∞)로. 이 값이 작아지면서 올바른 값으로 수렴하게 된다
    2. 현재 정점에서 갈 수 있는, 탐색하지 않은 정점들을 찾는다
    3. 각 후보 정점들의 가중치를 계산한다. **'가중치 = 시작 정점의 가중치 + 간선의 가중치'**
    4. **계산한 결과가 현재 정점의 값보다 작으면 가중치를 그 새로운 결과값으로 변경한다**
    5. **후보 정점 중에서 가중치가 가장 작은 정점을 선택한다.** 
    6. 2~5번의 과정을 반복한다
- 계산시간
    1. 정점 수를 n, 간선 수를 m이라 한다
    2. 아무런 고민을 하지 않는 경우에는 **O(n²)** 이다
    3. 데이터 구조를 고민하면 **O(m+n log n)** 이다
- 각 정점으로 향하는 최단 경로를 하나씩 정해가며 그래프를 탐색하는 알고리즘이다
- 가중치 계산과 변경을 모든 간선에 대해 반복하는 벨먼-포드 알고리즘과 달리, 정점 선택 방법을 고민해서 효율이 좋은 최단 경로를 구한다
- 다익스트라 알고리즘은 음수 가중치를 포함하는 그래프에서는 사용할 수 없다. 음수 가중치를 지닌 간선을 무시한 채로 최단 경로를 구하는 경우가 있기 때문이다
- 음수 가중치가 **없다면** 계산 시간이 빠른 **다익스트라 알고리즘**을 사용하고
- 음수 가중치가 **있다면** 계산 시간이 오래 걸리더라도 올바른 답을 도출하는 **벨먼-포드 알고리즘**을 사용하는 것이 좋다 

### :bulb: A* (에이 스타)
- 미리 추정 가중치를 설정해서 불필요한 탐색을 방지하도록 개선했다
    1. **시작점에서부터 실제로 걸린 시간을 가중치로** 정한 값과 **목표까지의 발견적 가중치를 설정한 값**을 더해서 **추정 가중치**를 계산한다
    2. 가중치가 가장 낮은 칸(노드, 정점)을 선택하며 전진한다
    3. 같은 작업을 목표에 도착할 때까지 반복한다
- 목표로부터 멀어지는 방향의 칸(노드, 정점)은 대부분 탐색되지 않는다. 그래서 효율적이다
- 각 지점에서 목표까지의 거리에 대한 힌트가 주어지는 경우에 유용하다

---

# :pushpin: 기타 알고리즘

### :bulb: 유클리드 알고리즘
- 두 수의 최대공약수를 구하는 알고리즘
    1. 큰 수를 작은 수로 나눈다
    2. 나눈 수(작은 수)를 나머지로 나눈다
    3. 반복한다
    4. 나머지가 0이 되었을 때 마지막 계산에서 나누는 수로 사용된 수가 두 수의 최대공약수가 된다 


### :bulb: 하노이의 탑
- n개의 원반 하노이 탑 문제는 n-1개의 하노이 탑을 해결하는 방식을 이용하면 된다
- 계산 시간은 **2^n - 1** 이다.