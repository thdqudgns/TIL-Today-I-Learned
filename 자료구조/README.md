# 자료구조 (Data Structure)

### :pushpin: 자료구조는 왜 필요한가?
사람들이 사물을 편리하고 효율적으로 사용하기 위해 정리하는 것과 마찬가지로 컴퓨터에서도 **자료를 효율적으로 사용하기 위해** 자료의 특성에 따라 **정리하고 조직화하는 여러 가지 구조**들이 있다. 이를 자료구조라고 한다.
자료구조가 얼마나 잘 구조화되어 있느냐에 따라 프로그램의 속도, 개발 시간, 유지보수 비용이 달라지기에 중요하다.

### :pushpin: 자료구조 분류

<details markdown="1">
<summary>자료의 형태에 따른 분류</summary>

* **단순구조**
   * 정수
   * 실수
   * 문자
   * 문자열

* **선형구조**
   * 리스트
   * 연결리스트
      * 단순 연결리스트
      * 이중 연결리스트
      * 원형 연결리스트
   * 스택
   * 큐
   * 데크

* **비선형구조**
   * 트리
      * 일반트리
      * 이진트리
   * 그래프
      * 방향그래프
      * 무방향그래프

* **파일구조**
   * 순차파일
   * 색인파일
   * 직접파일

</details>

이렇게 다양한 자료구조 중 상황에 따라 적절한 구조를 선택하는 기준은 다음과 같다.   
**데이터의 양, 데이터의 사용 빈도, 컴퓨터 기억장치의 양, 데이터에 대한 접근 시간, 데이터의 형태가 유지되는지 변경되는지**

### :pushpin: 알고리즘과 자료구조
* **알고리즘**
   - 알고리즘이란 계산이나 작업을 하기 위한 **순서**를 의미한다.
   - 알고리즘 간 **실행 시간의 차이**뿐만 아니라 같은 알고리즘에서도 **입력의 크기에 따른 알고리즘 계산 시간**이 얼만큼 달라지는지도 고려해야 한다.
   - 계산 시간에는 '**스탭 수**'를 활용한다. '1스탭'은 계산의 기본 단위로, '**계산을 종료하기까지 기본 단위를 몇 회 실행했는가**'로 계산 시간을 측정한다.
   - 계산 시간에서 입력개수 n이 커질 때 **가장 크게 영향을 받는 차수 하나만 남기고, 나머지는 지운다.**
   - O는 '중요한 항목 이외에는 무시한다'라는 의미를 가지는 기호다. '**빅오(Big O)**'라고 읽는다.
   - 빅오 표현을 통해 어떤 알고리즘이 빠른지, 입력의 크기 n의 변화에 따라 계산 시간은 얼마나 달라지는지 한눈에 파악할 수 있다.
* **자료구조**
   - 데이터를 메모리에 저장할 때 데이터의 **순서나 위치 관계** 등을 정하는 것이 '데이터 구조'다. (자료구조, Data Structure)
   - 데이터를 메모리에 저장할 때 목적에 맞게 구조화해서 메모리의 이용 효율을 높여야 한다.
   * :bulb: **리스트 List**
      - 리스트는 데이터를 일직선으로 나열한 형태를 가지고 있다. **데이터의 추가나 삭제는 쉽지만, 원하는 데이터에 접근하려면 시간이 많이 걸린다.**
      - 각 데이터에는 '**포인터(pointer)**'가 있으며, **다음 데이터의 메모리 위치**를 가리킨다.
      - 리스트에서는 데이터가 메모리의 연속된 위치에 저장되지 않아도 되며, **일반적으로 떨어진 영역에 흩어져서 저장된다.**
      - 흩어져서 저장되어 있으므로 **포인터를 처음부터 순서대로 따라가야만 원하는 데이터에 접근할 수 있다.**
      - 데이터의 추가와 삭제는 추가, 삭제할 위치의 앞뒤 포인터를 변경하면 된다.
      - 데이터에 **접근**할 때는 리스트의 앞에서부터 차례로 진행하기 때문에 **O(n)** 의 시간이 걸린다.
      - 데이터의 **추가와 삭제**는 두 개의 포인터만 변경하면 되기에 n에 상관없이 **O(1)** 이 된다. 물론 추가, 삭제할 위치에 이미 접근해 있는 것을 전제로 한다.
      - 리스트의 마지막 데이터의 포인터가 선두를 가리키도록 하면 리스트가 원형으로 연결된다. 이것을 '***원형(순환) 리스트***'라고 한다.
      - 포인터 두 개를 사용해서 앞뒤 데이터를 가리키도록 한 '***양방향 리스트***'도 있다. 단, 양방향 리스트에서는 포인터 수가 늘어남에 따라 데이터 저장을 위한 영역이 많아져야 하는 결점이 있다. 또한 데이터 추가나 삭제 시에 변경해야 할 포인터가 늘어난다.
   * :bulb: **배열 Array**
      - 데이터를 1열로 나열한 것이다. **데이터에 접근하기는 쉽지만, 추가나 삭제에 시간이 걸린다.**
      - 데이터는 **연속된 메모리 영역에 순차적으로 저장된다.** 연속된 영역에 있어서 index를 이용하여 메모리 주소를 계산할 수 있다. 따라서 각 데이터에 바로 접근할 수 있다.
      - 데이터를 추가, 삭제할 때는 기존의 데이터들을 한 칸씩 움직여야 하는 불편함이 있다.
      - 데이터에 **접근**할 때는 임의 접근할 수 있으므로 **O(1)** 
      - 데이터를 **추가, 삭제**할 때는 뒤에 있는 모든 데이터를 하나씩 옮겨야 하므로 **O(n)** 의 시간이 걸린다.
   * :bulb: **스택 Stack**
      - 데이터를 1열로 나열하지만, 새롭게 추가한 데이터에만 접근할 수 있다.
      - 스택에 데이터를 **추가**하는 작업을 '**push**', 데이터를 **꺼내는** 작업을 '**pop**'라고 한다.
      - 나중에 넣은 것을 먼저 꺼내는 **후입선출(Last In First Out, LIFO)구조**다.
      - 데이터 **추가나 삭제가 단방향**으로만 가능하다.
      - 중간에 있는 데이터가 필요하다면 해당 데이터가 제일 위에 올 때까지 데이터를 pop해야 한다.
   * :bulb: **큐 Queue**
      - 데이터를 1열로 나열한 구조다. 데이터를 추가하는 쪽과 삭제하는 측이 반대다. **줄 서 있는 행렬**을 생각하면 이해하기 쉽다. 
      - 먼저 넣은 것을 먼저 꺼낸다. **선입선출(First In First Out, FIFO)**
      - 큐에 데이터를 **추가**하는 작업을 '**인큐, enqueue**', 데이터를 **꺼내는** 작업을 '**디큐, dequeue**'라고 한다.
      - 스택과 마찬가지로 중간에 있는 데이터에 바로 접근할 수 없으며, 필요한 데이터가 나올 때까지 디큐를 해야 한다.
   * :bulb: **해시 테이블 Hash Table**
      - 해시 테이블은 **키와 값이 한 쌍을 이루는 데이터**를 저장한다.
      - 해시 테이블은 해시 함수를 이용해서 **배열** 내의 특정 데이터에 빠르게 접근할 수 있다.
      한편, 해시값이 충돌할 때는 **리스트**를 이용하고 있어서 저장할 데이터 수가 정해져 있지 않더라도 유연하게 대처할 수 있다.
      - 해시 테이블에 사용하는 배열의 크기는 너무 작으면 충돌이 많아지고, 선형탐색의 빈도가 높아지게 된다.
      - 반대로 배열이 너무 크면 데이터가 없는 상자가 많아져서 메모리를 낭비하게 된다. 따라서 배열의 크기를 적절히 설정하는 것이 중요하다.
   * :bulb: **힙 Heap**
      - 힙은 그래프의 **트리 구조** 중 하나로, '우선순위 큐(priority queue)'를 구현할 때 사용된다.
      - 추가는 자유롭게 하고 추출할 때는 작은 값부터 꺼내는 것이 우선순위 큐다.
      - 힙을 표현하는 트리구조에서는 각 정점을 '노드(node)'라고 부른다. 각 노드에 데이터가 저장된다.
      - 노드는 위에서부터 채워지며, 같은 층에서는 왼쪽부터 채워진다.
      - 힙에서는 데이터의 저장 위치를 정하기 위해 **자식 노드의 숫자는 반드시 부모의 숫자보다 커야 한다**는 규칙이 있다.
      - 새로운 값을 추가할 때, 부모의 숫자가 클 때는 규칙을 만족하지 않으므로 부모와 자식을 교환한다. 이런 처리를 교환이 발생하지 않을 때까지 **반복**한다.
      - 가장 위에 있는 숫자가 최솟값이므로, 힙에서 숫자를 꺼낼 때는 가장 위에 있는 숫자가 추출된다.
      - 가장 위에 있는 숫자가 없어지면, 가장 후미(가장 밑의 맨 오른쪽)에 있는 숫자를 가장 위로 이동시키고, 부모의 숫자가 작아지도록 교환을 반복한다.
      - **O(1)의 시간에 최솟값을 추출할 수 있다.**
      - **힙의 재구축 계산 시간은 트리의 높이에 비례하여 O(log n)이 된다.** 데이터 추가 시간도 마찬가지다.
      - **최솟값을 자주 추출해야 하는 경우**에는 힙이 편리하다.
   * :bulb:  **이진 탐색 트리**
      - **모든 노드는 왼쪽 가지에 포함되는 어떤 숫자보다도 큰 숫자가 된다.**
      - **모든 노드는 그 노드의 오른쪽 가지에 포함되는 어떤 숫자보다 작은 숫자가 된다.**
      - 따라서 이진 탐색 트리의 **최소 노드**는 최상단에 있는 노드로부터 **왼쪽 가지**만 계속 따라가면 나오는 **가장 끝에 있는 노드**가 된다.
      - 반대로, 이진 탐색 트리에서 **최대 노드**는 최상단의 노드로부터 **오른쪽 가지**만 계속 따라가면 나오는 **가장 끝에 있는 노드**가 된다.
      - 이진 탐색 트리에 노드를 추가하면, 노드 추가 위치를 최상단 노드부터 탐색해 간다. **작으면 왼쪽으로, 크면 오른쪽**으로 진행하면서 필요한 노드는 새로 추가한다.
      - 노드를 삭제할 때, 자식 노드가 없는 노드는 대상 노드를 삭제하면 작업이 끝난다.
      - 자식 노드가 하나인 노드를 삭제할 때는 대상 노드를 삭제하고, 자식 노드를 위로 이동시키면 끝난다.
      - 자식노드가 두 개인 경우는 먼저 대상 노드를 삭제하고, 삭제한 노드의 왼쪽 가지에서 최대 노드(or 오른쪽 가지에서 최소 노드)를 찾아서 삭제한 노드의 위치로 이동시킨다.
      - 노드를 탐색할 때에는 최상단 노드부터 탐색을 시작하여, 작으면 왼쪽으로, 크면 오른쪽으로 진행한다.
      - 트리의 높이만큼만 비교하면 되므로 노드가 n개 있고 트리가 균형 잡힌 경우라면 최대 log₂n회의 비교로 이동할 수 있다. 따라서 **탐색, 추가의 계산 시간은 O(log n)이 된다.**
      - 트리가 한쪽으로 치우쳐서 **직선에 가까운 모양일 때는 O(n)** 이 될 수도 있다.

### :pushpin: 정렬, Sort
주어진 숫자를 순서대로 나열하는 것.
* :bulb: **버블 정렬, Bubble Sort**
   - 오른쪽부터 왼쪽으로 **인접한 두 개의 숫자를 비교해서 교환하는 작업**을 반복한다. **작은 수가 왼쪽으로 가도록**
   - 1라운드를 거칠 때마다 가장 작은 숫자가 왼쪽 끝으로 이동한다. = **수열 중에서 가장 작은 숫자가 왼쪽 끝으로 이동할 때까지 교체하는게 한 라운드다.**
   - 그럼 2라운드에서는 왼쪽 끝을 제외하고, 왼쪽 끝에서 두 번째에 도착할 때까지 앞의 작업을 반복한다.
   - 버블정렬은 1라운드에서 n-1회, 2라운드에서 n-2회, n-1라운드에서 1회를 비교한다. 양 끝을 합치면 (n-1) + 1 = n 이고 라운드는 절반으로 줄어들므로 **비교횟수는 n x n/2가 된다.**
   - 따라서 버블정렬의 계산 시간은 **O(n²)** 이 된다.
* :bulb: **선택 정렬, Selection Sort**
   - **수열 중에서 선형탐색으로 최솟값을 검색해서 왼쪽 끝에 있는 숫자와 교체하는 작업을 반복한다.**
   - **선형탐색을 하고, 맨 왼쪽과 숫자를 바꾸는 것이 한 라운드다.**
   - 2라운드에서는 왼쪽 끝에서 두 번째에 있는 숫자와 교체한다. 즉, 남은 숫자 중에서 왼쪽 끝에 있는 숫자와 교체하는 것이다.
   - 최솟값이 이미 왼쪽 끝에 위치한 경우에는 아무런 작업을 하지 않는다.
   - 선형탐색으로 최솟값을 검색한 이후에는 왼쪽 끝과 바로 교체하기에, **선택정렬은 선형탐색 시간이 알고리즘 계산 시간이다.**
   - 선형탐색을 위해 1라운드에서 n-1회, 2라운드에서 n-2회, n-1라운드에서 1회 비교를 한다. 따라서 버블정렬과 같은 **O(n²)** 의 계산시간이 걸린다.
* :bulb: **삽입 정렬, Insertion Sort**
   - 수열의 **왼쪽부터 순서대로 정렬**하는 방식이다.
   - 처음에는 왼쪽 끝의 숫자를 정렬이 끝났다고 간주한다. 이것으로 1라운드가 종료된다.
   - 계속해서 **아직 작업하지 않은(미탐색 영역) 숫자 중에서 왼쪽 끝에 있는 숫자를 꺼내서 왼쪽에 있는 정렬이 끝난 숫자와 비교한다.** 왼쪽의 숫자가 크면 위치를 바꾼다. 이 작업을 자신보다 작은 숫자가 나타나거나 왼쪽 끝에 도착할 때까지 반복한다. 그렇게 교체가 멈추면 한 라운드가 끝난다.
   - 미탐색 영역의 숫자를 꺼내서 정렬시킬 때, 정렬 완료된 숫자와 대소비교하고 교체작업을 한다. **k라운드에서는 최대 k-1회까지 작업한다.** 2라운드에서 1회, 3라운드에서 2회, n라운드에서 n-1회의 비교와 교체가 발생한다. 계산시간이 버블정렬, 선택정렬과 같이 **O(n²)** 가 된다.
* :bulb: **힙 정렬, Heap Sort**
   - **힙이라는 데이터 구조를 사용한다.**
   - 처음에는 힙에 **내림차순**으로 숫자를 저장한다.
   - **내림차순 힙은 큰 것부터 순서대로 데이터를 추출하는 성질이 있으므로 꺼낸 숫자를 오른쪽부터 역순으로 나열하면 정렬이 완료된다.**
   - **숫자를 하나 꺼낼 때마다 힙을 재구축한다.** (마지막 노드를 최상단으로 옮기고, 비교하여 아래로 내리는 식으로)
   - 숫자를 꺼내는 것과 힙을 재구축하는 것을 반복한다. 모든 숫자를 힙에서 꺼내면 정렬이 완료된다.
   - **힙 정렬을 위해 n개의 숫자를 힙에 저장할 때 걸리는 시간은 O(n log n)이 된다.(숫자 하나 추가에 걸리는 시간 'log n' x 숫자의 개수 'n')** 빈 상태에서 데이터를 하나씩 추가하면 되지만, 힙의 높이가 log₂n 이하이므로 1회 추가에 O(log n)의 시간이 걸리기 때문이다. 또한, 각 라운드에서 최대 숫자를 꺼내서 힙을 재구축하는 데 걸리는 시간은 O(log n)이다. **라운드 수는 n이므로 힙이 완성된 후에 정렬하는 시간도 O(n log n)이 된다.(재구축 시간 'log n' x 라운드 수 'n')** 따라서 힙 정렬의 계산 시간은 전체적으로 O(n log n)이 된다.
   - 이것은 버블정렬, 선택정렬, 삽입정렬의 계산시간에 비해 빠른 속도다. 그러나 힙이라는 복잡한 데이터 구조를 구현하는 것이 어렵다.
* :bulb: **병합 정렬, Merge Sort**