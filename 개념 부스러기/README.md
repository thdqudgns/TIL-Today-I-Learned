# 개념 부스러기

### :pushpin: Garbage Collector (GC)
- 메모리를 관리한다. 필요없는 데이터들을 쓸어담아서 버린다.
- Mark-and-Sweep : 필요한 것들만 마크한 다음에, 마크 안 된 것들은 갖다버린다. 프로그래밍 측면에서 보면, root에서 닿지 않는 변수들을 치우는 것.
- Reference counting : 한 요소가 다른 요소에게 몇번이나 참조되었는지 세어서 그 수가 0이면 치운다.
- GC에도 한계가 있다. 지워야 할 것들을 100% 지우지 못한다. 그렇기 때문에 개발자 스스로 메모리 관리에 신경을 써야 한다.
- 언어마다 메모리 누수를 다루는 방법이 다르기 때문에, 언어/플랫폼/기기마다의 바람직한 메모리관리 방식을 이것저것 알아볼 필요가 있다.
- 보편적인 규칙으로 순환참조를 안 하는 것이 있다. 왜냐하면 Reference counting이 0이 안되기 때문이다.

### :pushpin: try-catch? 예외처리란 뭔가요?
- 컴파일 오류 : 문법 오류를 말한다. 이는 코딩하다가 발견된다. 개발도구에서 밑줄로 알려준다.
- 런타임 오류 : 컴파일 오류 없이 실행은 되었지만, 실행 중 오류가 발생하는 것이다. 개발자의 논리적 결함에 의해 발생하기에 '논리 오류'라고도 한다.
- 개발자가 모든 오류를 다 예측할 수는 없다. 그래서 개발언어들은 돌발상황에 대처하기 위해 '예외처리'란 장치가 있다. ( Java: try-catch / Python: try-except / Ruby: begin-rescue )
- 오류가 발생할 수 있는 곳을 예측해서 try로 감싸놓은 부분은 뭐가 잘못되더라도 프로그램이 종료되지 않고, catch 블록에서 대응하게끔 하고 다음 과정으로 넘어가도록 한다. 그리고 오류가 나든 안 나든 finally 블록을 마지막으로 실행한다. 접속을 시도했다가 접속을 종료해야 하는 서비스 등에서 finally가 많이 사용된다.

### :pushpin: Scope가 뭔가요? ( + JS에서 let, const, var의 차이 )
- 각 상수나 변수등의 요소들에게 허용된 영역, 범위
- 전역변수, 정적변수들은 메모리에 올라가서 프로세스가 종료될 때까지 수거되지 않는다. 정적클래스의 정적변수들은 클래스의 객체를 생성할 필요도 없이 코드 내 어디든 돌아다닐 수 있다.
- 모든 변수들이 메모리에 올라가면 메모리에 자리가 안 남을 것이다.
- 그래서 특정함수나 조건/반복문 등에서 쓰이는 변수들과, 동적으로 여럿이 생성될 수 있는 클래스의 객체 등은 볼 일을 다 보면 방을 빼도록 시스템적으로, 수동으로, Garbage Collector로 관리된다.
- Stack(후입선출)을 생각하면 된다. push되어 쓰이다가 다 쓰면 pop된다.
- 블록{}의 바깥 영역에서 선언된 변수들을 블록{} 안에 같은 이름으로 선언하면, 안쪽의 블록{} 영역에서 해당 변수명을 호출할 때 안쪽에서 선언된 변수로 접근하게 된다. 이렇게 외부에서 선언된 변수가 내부에서 활용되지 못하도록 막는다. 보통 변수를 찾을 때 안쪽부터 바깥쪽으로 찾기 때문이다.
- 추가적인 특징으로, 전역변수를 사용하다 의도치 않게 변수명이 겹칠 때 충돌이나 오류가 발생할 여지가 있기 때문에 불가피한 상황이 아니면 전역변수를 사용하지 않는다.
- const: 선언과 초기화를 동시에 진행해주어야 한다. 한 번 넣은 값을 바꿀 수 없는 상수다.
```java
    const constname = '문자';
```
- let: 선언과 초기화를 따로 할 수 있다. 넣은 값을 얼마든지 바꿀 수 있다. 대신, 똑같은 이름으로 선언을 다시 할 수는 없다.
- var: 
    - 익스플로러 브라우저의 존재 때문에 배포용 코드에는 var 변수들만 사용된다.
    - 선언과 초기화를 따로 할 수 있고, 값을 변경할 수 있으며, 똑같은 이름으로 다시 선언하는 것도 가능하다. 
    - hoisting으로 선언부 위에서 사용될 수도 있다. 즉, 사용 이후에 선언을 하더라도 오류없이 작동한다. (결과는 undefined로 나오지만, 일단 사용은 할 수 있음)
    - 그리고 const와 let은 선언된 블록{} 안에서만 사용이 가능하지만, var 변수는 선언부가 함수 내부이기만 하면 블록에서 선언되었더라도 함수 내부 어디든 돌아다닐 수 있다. 함수영역 전체가 scope인 것이다.

### :pushpin: 재귀함수가 뭔가요? (Recursive function)
- 자기 자신을 호출하는 함수를 말한다.
- 단순한 문제는 for, while문으로 변경할 수 있지만, 복잡한 문제라면 재귀함수가 나을 수도 있다. 재귀함수를 이용했을 때 보다 효율적으로 코드를 짤 수 있는 문제들이 있다. 여러 단계를 포함하는 문제가 그렇다.
- 재귀함수는 호출될 때마다 메모리의 Stack에 쌓이게 된다. 한계치 이상으로 호출돼서 Stack이 넘쳐버리면 메모리 부족으로 에러가 발생할 것이다.
- 속도면에서도 재귀함수는 jump가 잦아서 반복문에 비해 시간을 더 소모한다.
- 이런 문제를 해결하기 위해 많은 언어들에서 **[꼬리 재귀 최적화]**라는 기능을 제공한다. 
    - 재귀함수를 컴퓨터가 재해석해서 선형 알고리즘으로 만들어 실행하는 것이다. 
    - 그럼 반복이 많이 일어나도 Stack이 넘치는 일은 발생하지 않는다.
    - 그러니 재귀함수를 쓰려면, 해당 개발언어가 **[꼬리 재귀 최적화]**를 지원하는지 확인하는게 좋다.
    - 재귀함수가 꼬리 재귀가 되려면, return하는 값이 **'함수 그 자체'**만 호출하는 형태여야 한다.
- 하노이의 탑 문제에 적용 가능하다.

### :pushpin: 프로세스? 쓰레드?
- 이름 뒤에 '.exe'가 붙어있는 파일 = 프로그램
- 프로그램이 실행되어 돌아가고 있는 상태 = 프로세스
- 운영체제(OS)가 여러개의 프로세스를 함께 돌리고 있기에 컴퓨터를 쾌적하게 사용할 수 있는 것이다.
    - 운영체제가 여러 프로세스를 함께 작동시키는 방식 2가지:
    - 동시성(Concurrency): 프로세서 하나가 로테이션으로 움직이며(= Context Switching) 각각의 프로그램들을 일부분씩 진행한다. 진행되는 속도가 빨라서 동시에 진행되는 것처럼 보인다.
    - 병렬성(Parallelism): 프로세서 하나에 코어 여러 개가 달려서, 각각의 코어마다 프로그램 하나씩 담당하여 진짜로 동시에 작업을 수행한다.
- 한 프로세스 안에도 **여러 갈래**의 작업들이 동시에 진행될 필요가 있다. (게임 받으면서 영상 보기 등)
- 이 여러 갈래가 쓰레드다.
- 프로세스들은 한 컴퓨터의 자원을 분할해서 사용하지만, 쓰레드는 여러 쓰레드들이 하나의 프로세스에 속해서, 프로세스에 주어진 전체 자원을 함께 사용한다.

### :pushpin: 비동기 프로그래밍
- 동기 = 순서대로
- 비동기 = 순서대로 안 함, 프로세스나 쓰레드가 여럿이 동작하고 있다.
- 비동기로 주어진 일을 다 마친 다음에 어떤 함수를 실행하도록 업무를 맡겨놓는 함수 = 콜백함수
- JS는 싱글쓰레드지만, WebAPI를 통해 비동기로 동작시킬 수 있다.
- 비동기로 동작하며, Task Queue라는 하나의 선로에 콜백칸을 올려보낸다.
- 이 콜백칸들은 Task Queue 선로를 따라 다시 JS 싱글쓰레드 선로에 돌아오게 된다. 돌아오게 하는 역할을 하는 장치를 '이벤트 루프'라고 한다.
- 콜백을 계속하면 콜백 지옥에 빠진다. 디버깅도 어럽다. 이런 문제를 해결하기 위해 JS는 ES6 버전부터 Promise란 걸 도입했다. 비동기 작업을 수행하는 함수가 Promise의 객체를 반환하는데, 그 생성자에 인자로 들어가는 함수에 첫번째 인자로는 수행할 비동기 작업, 두번째 인자로는 그 결과물을 콜백함수에 전달하는 함수가 들어간다.
- Promise를 반환하는 함수는 그 결과물에 'then'이란 함수로 다음 작업을 알려주기 위한 콜백을 넣어줄 수 있다. then-then-then... 이렇게 then 함수로 꼬리에 꼬리를 잇는 체이닝 방식으로 비동기 작업들을 순차적으로 처리할 수 있다.

### :pushpin: 포인터가 뭐고 왜 쓰는건가?
- 메모리 공간을 중복해서 사용하지 않고, 포인터로 데이터의 위치를 알려줘서 메모리 공간을 절약한다.
- 참조에 의한 호출 (Call By Reference)

### :pushpin: 객체지향 프로그래밍
- 프로그래밍을 더 잘하기 위해 만들어졌다.
- 함수 or 메소드라 불리는 기능을 사용하면 하나하나 입 아프게 말하지 않고도 지시를 내릴 수 있다.
- 여기까지는 절차적 프로그래밍에서도 가능한 작업이다. 그러나 데이터가 많아지고 작업이 복잡해지면 개발하기 벅찰 것이다.
- 클래스 안에 [필드]() 를 정의하고, [생성자]()를 작성하고, [메소드]()를 작성한다.
- 데이터(필드)와 기능(메소드)이 클래스로 캡슐화 된 컴퓨터 자원의 묶음을 '객체'라고 한다.
- 객체지향 프로그래밍을 배운 뒤로는, '클래스'라는 모양틀을 만들고, 자원을 그 틀에 넣어서 구우면 모양과 용도가 뚜렷한 벽돌들이 만들어진다.
- 그저 시키는대로 일하던 예전과 달리, 뚜렷한 역할들을 갖게 되었다.
- 은닉성: 내부구조는 private로 감춰놓고, 외부에서 조작할 수 있는 명령어만 public으로 공개하는 것. => 바깥의 간섭으로 발생하는 오류를 방지할 수 있다. 남이 만든 클래스의 객체들을 일일히 뜯어 볼 필요없이 제공되는 기능들을 그대로 사용할 수 있다.
- 클래스 타입으로 변수를 생성하고, 그 클래스 안에 있는 메소드를 실행시킨다.
```java
클래스명 변수명 = new 클래스명(인자);
변수명.메소드명(); // 클래스 생성시, 그 안에 작성되어 있던 메소드.   

// 클래스 {
//    필드;
//    생성자;
//    메소드;
// }
}
```
- interface를 만들고, 여러 클래스에서 이 interface를 implement 시키면, interface 안에 있는 메소드를 @Override 하여 필수적으로 메소드를 정의하게 한다. 그럼 각각의 클래스 타입으로 만든 객체변수들로 동일한 메소드의 실행을 가능하게 해서 중복을 줄일 수 있다. 같은 interface를 적용한 클래스들이기 때문에 가능한 것이다.

