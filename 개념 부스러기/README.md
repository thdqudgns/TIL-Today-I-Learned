# :cookie: 개념 부스러기
(출처: [얄팍한코딩사전](https://www.youtube.com/channel/UC2nkWbaJt1KQDi2r2XclzTQ))

### :pushpin: Garbage Collector (GC)
- 메모리를 관리한다. 필요없는 데이터들을 쓸어담아서 버린다.
- **Mark-and-Sweep** : 필요한 것들만 마크한 다음에, 마크 안 된 것들은 갖다버린다. 프로그래밍 측면에서 보면, root에서 닿지 않는 변수들을 치우는 것.
- **Reference counting** : 한 요소가 다른 요소에게 몇번이나 참조되었는지 세어서 그 수가 0이면 치운다.
- GC에도 한계가 있다. 지워야 할 것들을 100% 지우지 못한다. 그렇기 때문에 개발자 스스로 메모리 관리에 신경을 써야 한다.
- 언어마다 메모리 누수를 다루는 방법이 다르기 때문에, 언어/플랫폼/기기마다의 바람직한 메모리관리 방식을 이것저것 알아볼 필요가 있다.
- 보편적인 규칙으로 순환참조를 안 하는 것이 있다. 왜냐하면 Reference counting이 0이 안되기 때문이다.

### :pushpin: try-catch? 예외처리란 뭔가요?
- **컴파일 오류** : 문법 오류를 말한다. 이는 코딩하다가 발견된다. 개발도구에서 밑줄로 알려준다.
- **런타임 오류** : 컴파일 오류 없이 실행은 되었지만, 실행 중 오류가 발생하는 것이다. 개발자의 논리적 결함에 의해 발생하기에 '논리 오류'라고도 한다.
- 개발자가 모든 오류를 다 예측할 수는 없다. 그래서 개발언어들은 돌발상황에 대처하기 위해 '예외처리'란 장치가 있다. ( Java: try-catch / Python: try-except / Ruby: begin-rescue )
- 오류가 발생할 수 있는 곳을 예측해서 try로 감싸놓은 부분은 뭐가 잘못되더라도 프로그램이 종료되지 않고, catch 블록에서 대응하게끔 하고 다음 과정으로 넘어가도록 한다. 그리고 오류가 나든 안 나든 finally 블록을 마지막으로 실행한다. 접속을 시도했다가 접속을 종료해야 하는 서비스 등에서 finally가 많이 사용된다.

### :pushpin: Scope가 뭔가요? ( + JS에서 let, const, var의 차이 )
- 각 상수나 변수등의 요소들에게 허용된 영역, 범위
- 전역변수, 정적변수들은 메모리에 올라가서 프로세스가 종료될 때까지 수거되지 않는다. 정적클래스의 정적변수들은 클래스의 객체를 생성할 필요도 없이 코드 내 어디든 돌아다닐 수 있다.
- 모든 변수들이 메모리에 올라가면 메모리에 자리가 안 남을 것이다.
- 그래서 특정함수나 조건/반복문 등에서 쓰이는 변수들과, 동적으로 여럿이 생성될 수 있는 클래스의 객체 등은 볼 일을 다 보면 방을 빼도록 시스템적으로, 수동으로, Garbage Collector로 관리된다.
- Stack(후입선출)을 생각하면 된다. push되어 쓰이다가 다 쓰면 pop된다.
- 블록{}의 바깥 영역에서 선언된 변수들을 블록{} 안에 같은 이름으로 선언하면, 안쪽의 블록{} 영역에서 해당 변수명을 호출할 때 안쪽에서 선언된 변수로 접근하게 된다. 이렇게 외부에서 선언된 변수가 내부에서 활용되지 못하도록 막는다. 보통 변수를 찾을 때 안쪽부터 바깥쪽으로 찾기 때문이다.
- 추가적인 특징으로, 전역변수를 사용하다 의도치 않게 변수명이 겹칠 때 충돌이나 오류가 발생할 여지가 있기 때문에 불가피한 상황이 아니면 전역변수를 사용하지 않는다.
- **const**: 선언과 초기화를 동시에 진행해주어야 한다. 한 번 넣은 값을 바꿀 수 없는 상수다.
```java
    const constname = '문자';
```
- **let**: 선언과 초기화를 따로 할 수 있다. 넣은 값을 얼마든지 바꿀 수 있다. 대신, 똑같은 이름으로 선언을 다시 할 수는 없다.
- **var**: 
    - 익스플로러 브라우저의 존재 때문에 배포용 코드에는 var 변수들만 사용된다.
    - 선언과 초기화를 따로 할 수 있고, 값을 변경할 수 있으며, 똑같은 이름으로 다시 선언하는 것도 가능하다. 
    - hoisting으로 선언부 위에서 사용될 수도 있다. 즉, 사용 이후에 선언을 하더라도 오류없이 작동한다. (결과는 undefined로 나오지만, 일단 사용은 할 수 있음)
    - 그리고 const와 let은 선언된 블록{} 안에서만 사용이 가능하지만, var 변수는 선언부가 함수 내부이기만 하면 블록에서 선언되었더라도 함수 내부 어디든 돌아다닐 수 있다. 함수영역 전체가 scope인 것이다.

### :pushpin: 재귀함수가 뭔가요? (Recursive function)
- 자기 자신을 호출하는 함수를 말한다.
- 단순한 문제는 for, while문으로 변경할 수 있지만, 복잡한 문제라면 재귀함수가 나을 수도 있다. 재귀함수를 이용했을 때 보다 효율적으로 코드를 짤 수 있는 문제들이 있다. 여러 단계를 포함하는 문제가 그렇다.
- 재귀함수는 호출될 때마다 메모리의 Stack에 쌓이게 된다. 한계치 이상으로 호출돼서 Stack이 넘쳐버리면 메모리 부족으로 에러가 발생할 것이다.
- 속도면에서도 재귀함수는 jump가 잦아서 반복문에 비해 시간을 더 소모한다.
- 이런 문제를 해결하기 위해 많은 언어들에서 **[꼬리 재귀 최적화]**라는 기능을 제공한다. 
    - 재귀함수를 컴퓨터가 재해석해서 선형 알고리즘으로 만들어 실행하는 것이다. 
    - 그럼 반복이 많이 일어나도 Stack이 넘치는 일은 발생하지 않는다.
    - 그러니 재귀함수를 쓰려면, 해당 개발언어가 **[꼬리 재귀 최적화]**를 지원하는지 확인하는게 좋다.
    - 재귀함수가 꼬리 재귀가 되려면, return하는 값이 **'함수 그 자체'**만 호출하는 형태여야 한다.
- 하노이의 탑 문제에 적용 가능하다.

### :pushpin: 프로세스? 쓰레드?
- 이름 뒤에 '.exe'가 붙어있는 파일 = 프로그램
- 프로그램이 실행되어 돌아가고 있는 상태 = 프로세스
- 운영체제(OS)가 여러개의 프로세스를 함께 돌리고 있기에 컴퓨터를 쾌적하게 사용할 수 있는 것이다.
    - 운영체제가 여러 프로세스를 함께 작동시키는 방식 2가지:
    - **동시성(Concurrency)** : 프로세서 하나가 로테이션으로 움직이며(= Context Switching) 각각의 프로그램들을 일부분씩 진행한다. 진행되는 속도가 빨라서 동시에 진행되는 것처럼 보인다.
    - **병렬성(Parallelism)** : 프로세서 하나에 코어 여러 개가 달려서, 각각의 코어마다 프로그램 하나씩 담당하여 진짜로 동시에 작업을 수행한다.
- 한 프로세스 안에도 **여러 갈래**의 작업들이 동시에 진행될 필요가 있다. (게임 받으면서 영상 보기 등)
- 이 여러 갈래가 쓰레드다.
- 프로세스들은 한 컴퓨터의 자원을 분할해서 사용하지만, 쓰레드는 여러 쓰레드들이 하나의 프로세스에 속해서, 프로세스에 주어진 전체 자원을 함께 사용한다.

### :pushpin: 비동기 프로그래밍
- 동기 = 순서대로
- 비동기 = **순서대로 안 함, 프로세스나 쓰레드가 여럿이 동작하고 있다.**
- 비동기로 주어진 일을 다 마친 다음에 어떤 함수를 실행하도록 업무를 맡겨놓는 함수 = 콜백함수
- JS는 싱글쓰레드지만, WebAPI를 통해 비동기로 동작시킬 수 있다.
- 비동기로 동작하며, Task Queue라는 하나의 선로에 콜백칸을 올려보낸다.
- 이 콜백칸들은 Task Queue 선로를 따라 다시 JS 싱글쓰레드 선로에 돌아오게 된다. 돌아오게 하는 역할을 하는 장치를 '이벤트 루프'라고 한다.
- 콜백을 계속하면 콜백 지옥에 빠진다. 디버깅도 어럽다. 이런 문제를 해결하기 위해 JS는 ES6 버전부터 Promise란 걸 도입했다. 비동기 작업을 수행하는 함수가 Promise의 객체를 반환하는데, 그 생성자에 인자로 들어가는 함수에 첫번째 인자로는 수행할 비동기 작업, 두번째 인자로는 그 결과물을 콜백함수에 전달하는 함수가 들어간다.
- Promise를 반환하는 함수는 그 결과물에 'then'이란 함수로 다음 작업을 알려주기 위한 콜백을 넣어줄 수 있다. then-then-then... 이렇게 then 함수로 꼬리에 꼬리를 잇는 체이닝 방식으로 비동기 작업들을 순차적으로 처리할 수 있다.

### :pushpin: 포인터가 뭐고 왜 쓰는건가?
- 메모리 공간을 중복해서 사용하지 않고, 포인터로 **데이터의 위치를 알려줘**서 메모리 공간을 절약한다.
- 참조에 의한 호출 (Call By Reference)

### :pushpin: 객체지향 프로그래밍
- 프로그래밍을 더 잘하기 위해 만들어졌다.
- 함수 or 메소드라 불리는 기능을 사용하면 하나하나 입 아프게 말하지 않고도 지시를 내릴 수 있다.
- 여기까지는 절차적 프로그래밍에서도 가능한 작업이다. 그러나 데이터가 많아지고 작업이 복잡해지면 개발하기 벅찰 것이다.
- 클래스 안에 [필드]() 를 정의하고, [생성자]()를 작성하고, [메소드]()를 작성한다.
```java
// 클래스 {
//    필드;
//    생성자;
//    메소드;
// }
```
- 데이터(필드)와 기능(메소드)이 클래스로 캡슐화 된 컴퓨터 자원의 묶음을 '객체'라고 한다.
- 객체지향 프로그래밍을 배운 뒤로는, '클래스'라는 모양틀을 만들고, 자원을 그 틀에 넣어서 구우면 모양과 용도가 뚜렷한 벽돌들이 만들어진다.
- 그저 시키는대로 일하던 예전과 달리, 뚜렷한 역할들을 갖게 되었다.
- 은닉성: 내부구조는 private로 감춰놓고, 외부에서 조작할 수 있는 명령어만 public으로 공개하는 것. => 바깥의 간섭으로 발생하는 오류를 방지할 수 있다. 남이 만든 클래스의 객체들을 일일히 뜯어 볼 필요없이 제공되는 기능들을 그대로 사용할 수 있다.
- 클래스 타입으로 변수를 생성하고, 그 클래스 안에 있는 메소드를 실행시킨다.
```java
클래스명 변수명 = new 클래스명(인자);
변수명.메소드명(); // 클래스 생성시, 그 안에 작성되어 있던 메소드.   
```
- interface를 만들고, 여러 클래스에서 이 interface를 implement 시키면, interface 안에 있는 메소드를 @Override 하여 필수적으로 메소드를 정의하게 한다. 그럼 각각의 클래스 타입으로 만든 객체변수들로 동일한 메소드의 실행을 가능하게 해서 중복을 줄일 수 있다. 같은 interface를 적용한 클래스들이기 때문에 가능한 것이다.
- interface로 묶이지 않은 각각 다른 클래스에서 메소드명만 똑같이 하는 걸로는 이게(다른 클래스 타입의 객체에서 동일한 메소드를 실행하는 것) 되지 않는다.
- 그리고 객체지향에서는 클래스들을 갖고 또다른 클래스를 조립해낼 수 있다. 자원들을 조금 더 큰 단위로 묶을 수 있는 것이다.
- 기존의 클래스에 추가로 필요한 기능들을 넣어 새로운 클래스를 만들 때는 클래스를 통째로 새로 만들지 않는다. 중복이 많기 때문이다. 이때 객체지향의 '상속'을 이용할 수 있다. 기존 클래스를 부모클래스로 해서 여기에 필요한 것들을 더 추가한 자식클래스를 만드는 것이다. extends로 부모클래스를 상속받는다. 변수들과 메소드들을 그대로 물려받는다. 그래서 새로운 변수, 메소드마다 추가할 것만 새로 추가하면 된다.
- 부모클래스에서 정의된 메소드의 작업이 자식클래스에서 다른 걸로 override 되는 것. 대체될 수 있는 걸 객체지향의 '다형성'이라고 한다.
- '상속'은 물려받는 것, 'interface'는 장착하는 것이라 생각하면 편하다.
- '객체지향'이라는 것은 프로그래밍 방법론이기 때문에, '객체지향 언어'라고 불리지 않는 언어에서도 사용할 수 있는 방법이다.

### :pushpin: 함수형 프로그래밍
- 프로그래머들이 일하는 새로운 패러다임을 제시한다.
- 인풋과 아웃풋이 있다. 외부환경으로부터 독립적이다. 같은 인풋이면 언제나 같은 아웃풋을 생산해낸다. => 이런 걸 "순수함수"라고 부른다.
- 함수형 프로그래밍이 주목받게 된 이유 중 하나가, 외부환경에 의한 부작용으로부터 자유롭다는 것이다. 여기서 말하는 '부작용'이란 어떤 함수의 동작에 의해 프로그램 내 특정상태가 변경되는 상황을 말한다. 변경된 상태는 관련된 다른 동작들에게 영향을 미칠 것이다. 이 문제를 수동적인 방법으로 해결하려고 하면 구현이 어렵고, 주의를 필요로 한다. 시간차에 의한 오류의 가능성들을 다 감안해야 하기 때문에 예상치 못한 오류가 날 수 있다. 함수형 프로그래밍은 함수의 동작에 의한 변수의 부수적인 값 변경을 원천 배제함으로써 이런 종류의 오류를 방지한다.
- 코드를 짤 때 100%로 함수형 프로그래밍을 하는게 아니다. 일정 단위의 작업에 적용시킨다.
- 함수형 프로그래밍의 특징과 요소 : 
    1. **선언형이다.** : 이거는 이거다! 뭘 넣으면 무엇이 나오는지 정해져있다.
    2. **함수도 '값'이다.** : 인자만 붙여주면 언제나 예측가능한 값을 내게 된다.
    3. **고계함수** : 인자로 다른 함수를 받아 결과값을 내보내는 함수
    4. **커링** : 여러 인자를 받는 함수에 일부 인자만 넣어서, 나머지 인자를 받는 다른 함수를 만들어낼 수 있는 함수형 프로그래밍의 기법.
    5. **함수 컴비네이터** : 

### :pushpin: 객체지향 디자인 패턴

+ **Singleton 싱글톤**
    - 어떤 클래스의 객체가 해당 프로세스에서 딱 하나만 만들어져 있어야 할 때가 있다.
    - 싱글톤 클래스에서 '생성자'를 private로 만든다.(이렇게 하면 다른 클래스에서 싱글톤 클래스의 객체를 생성할 때 new로 객체를 생성하지 못한다.) 그리고 static으로 싱글톤 클래스 자신 타입의 객체를 하나 만든다.(클래스 안의 static이 아닌 변수나 메소드들은 객체가 생성될 때마다 메모리의 공간을 새로 차지하지만, static으로 선언된 것들은 객체가 얼마나 만들어지든 메모리의 지정된 공간에 딱 하나씩만 존재하게 된다. 컴파일 할 때부터 static 요소가 차지할 메모리 용량이 정해져있기 때문에, static이 없는 동적인 요소(변수,메소드)들과 대비되는 개념으로 static(정적)이라 불린다.)
    ```java
    public class Settings {
        private Settings() {}; //생성자 -> 다른 클래스에서 'new'로 객체를 생성하지 못한다.
        private static Settings settings = null; //자기자신 클래스 타입의 정적 객체 생성 -> 메모리의 지정된 공간에 하나만 존재하게 됨
        public static Settings getsettings(){ // 정적 메소드 getsettings
            if(settings == null) {
                settings = new Settings();
            }
            return settings;
        }
        // 다른 곳에서 이 getsettings 메소드를 실행하기 전이라면 Settings 객체를 new로 선언해서 settings 변수에 넣어주고, 어디선가 이미 getsettings 메소드를 실행해서 settings가 만들어진 상태라면 그걸 그대로 return으로 반환해준다.
    }
    ```
    - 다른 클래스에서 settings 변수에 값을 넣는 부분을 다음과 같이 한다. 'new'로 생성하지 않고, '클래스명.해당 클래스의 메소드명' 으로 클래스에서 바로 불러낸다. 왜냐하면 static 메소드는 이미 메모리의 정적 공간에 자리를 차지하고 있는 상태기 때문이다.
    ```java
    private Settings settings = Settings.getsettings();
    // 싱글톤인 Settings 클래스의 정적 메소드인 getsettings()를 호출.
    ```
+ **Strategy pattern 전략패턴**
    - 옵션들 마다의 행동들을 모듈화해서 독립적이고 상호 교체가 가능하도록 만드는 것.
    - interface 타입으로 변수를 지정한다는 건, 해당 인터페이스를 구현(implements)한 클래스의 객체가 변수에 대입된다는 뜻이다. 이 클래스들은 인터페이스의 메소드를 갖는다.

+ **State pattern 상태패턴**
    - 위의 전략패턴은 어떤 동일한 틀 안에 있는 특정 작업의 방식, 모드를 바꿔줄 때 사용.
    - State pattern은 on-off처럼 특정 상태마다 다르게 할 일을, 나아가서 그 상태들 자체를 그 상태마다 실행시 할 일과 함께 하나하나 모듈화해서 지정해둘 때 쓰인다.
    - 전략패턴이 지정된 특정 메소드가 모듈화 된 모드에 따라 다르게 실행되도록 하는 것이라면, State pattern은 그 메소드가 실행될 때 모드도 전환되도록 하는 것.

+ **Command pattern**
    - 전략패턴은 같은 일을 하되, 그 알고리즘이나 방식이 갈아끼워지는 거라면, Command pattern은 각각 하는 일 자체가 다르다.
    - 여러 작업을 수행한 뒤, 뒤로가기나 앞으로가기를 구현하는 등 다양한 방식으로 활용될 수 있다.

+ **Adapter pattern**
    - 형식이 다른 둘 사이를 연결해서 호환될 수 있도록 해주는 도구.
    - 인터페이스가 서로 다른 객체들이 같은 형식 아래 작동할 수 있도록 하는 역할을 한다.
    - 요리사와 제빵사가 있다. "제빵사님, 제가 '요리해주세요'**라고 말해도 제빵을 해주세요!(=Adapter)** 아시겠죠?" "요리해주세요" -> 요리사는 요리를, 제빵사는 제빵을 수행.

+ **Proxy pattern 대리인패턴**
    - 인터넷에서 받아와야 해서 시간이 좀 걸리거나 메모리를 많이 차지하거나 하는 등의 이유로, 객체로 여럿을 생성하기 부담되는 것들이 있다. 그럴 때 그 클래스의 대리인 역할을 하는 클래스를 따로 두어서, 가벼운 일은 대리인이 처리하고, 무거운 작업에만 원래 클래스를 생산해서 사용한다.
    - **예)** 유튜브에서 동영상 위에 마우스오버 할 때에 프리뷰 기능: 
        - 제목 보여주기 -> Proxy 클래스
        - 프리뷰 보여주기 -> 실제 클래스
    - 필요할 때에만 실제 객체를 생성하기 때문에 효율적이고 유연한 개발이 가능하다.

+ **Facade pattern**
    - 여러 클래스의 객체들을 복합적으로 사용해서 기능을 수행할 때, 그 여러 클래스의 객체들을 수행하는 하나의 새로운 클래스를 만드는 것.
    - 이로써 '클래스명.메소드명()' 코드 한 줄로 실행되도록 할 수 있다. 
    - 평소에 이렇게 많이 쓴다.
    - 사용자측에서 복잡한 연결관계를 알 필요가 없기 때문에 '외벽'을 뜻하는 facade 뒤에 원래 코드들을 숨겨두고, 작업을 수행할 때에는 이 외벽에 달린 메소드만 실행하면 되도록 코드를 짜는 것이다.

+ **Template-method pattern**
    - 어떤 같은 형식을 지닌 특정 작업들의 세부 방식을 다양화하고자 할 때 사용.
    - 다양화 된 방식을 각각 자식 클래스들에서 오버라이딩 하는 방식으로 구현한다.
    - 메인메소드와 그 내부의 세부메소드들이 있는데, 자식클래스에서는 그 세부메소드를 오버라이딩 한다.
    - **예)** 떡볶이를 만드는 레시피에서 '소스 만들기 -> 떡 넣기 -> 채소 넣기' 순서로 조리가 진행되는데, 각 순서에서 다양한 방식을 적용시킬 수 있다. 원하는 소스를 넣거나, 원하는 채소를 넣거나 말이다. 여기서 '정해진 순서'가 메인메소드고, '다양한 방식'이 세부메소드다.

+ **Decorator pattern**
    - 특정 클래스의 객체들이 할 수 있는 일을 여러가지 두고, 각 객체마다 사용자가 원하는대로 골라 시키거나 기능들을 필요에 따라 장착할 수 있도록 할 때 사용한다.
    - **예)** 비행기 슈팅게임에서 비행기가 아이템을 먹을 때마다 공격 미사일이 추가된다.
    - 객체가 생성자 변수로서 다른 객체 안에 들어감으로써 실행하는 메소드의 행동이 추가되도록 하는 것.

+ **Factory-method pattern**
    - 객체들을 생성하는 코드는 여러곳에 있을 수 있다. 그런데 생성자가 변경되기라도 하면 객체 생성 코드들을 하나하나 찾아서 새 생성자 형식에 맞게 코드들을 변경해야 할 것이다. 개수가 많아질수록 변경하기 부담스러울 것이다.
    - 팩토리 클래스에게 코드를 변경하는 일을 시키면, 팩토리 클래스 내부의 메소드만 변경시키면 될 것이다.
    - 조건에 따라 객체를 생성해 가져오는 일을 팩토리 클래스에 위임해버림으로써, 객체를 생성할 때 클래스들에 대해 알 필요가 없도록 한다.
    - 개발자들은 기존에 만들어진 라이브러리, 클래스들을 활용한다. 특정 기능에 사용될 수 있는 클래스들의 종류가 많고 복잡할 때, 이를 사용하는 개발자 측에서는 클래스들을 다 알 필요없이 사용할 객체의 조건들만 인자로 넘겨주면, 이에 적절한 클래스를 찾아 객체를 생성해 넘겨주는 일은 팩토리가 알아서 처리한다.

+ **Abstract-factory pattern**
    - 팩토리 메소드 패턴에 추상화가 입혀진 패턴. 팩토리도 여러 종류로 만드는 것.
    - **예)** 테마 -> 기본 팩토리를 추상클래스나 인터페이스로 하나 만들고, 이를 상속한 테마마다의 팩토리를 둬서, 처음부터 어떤 팩토리를 세우느냐에 따라 찍혀나오는 요소들의 테마가 달라지도록 할 수 있을 것이다.

+ **Mediator pattern (중재자)**
    - 어떤 클래스의 객체에서 특정 이벤트가 발생할 때마다, 연결된 다른 클래스에 알려야 하는 경우들이 있다.
    - 특정 이벤트에 반응해서 관련된 다른 클래스들에게 알려주는 일을 중재자 역할을 하는 클래스에 전담시킨다. (거래처에 전화를 돌릴 외주업체를 따로 두는 것과 비슷함)
    - 중재자 역할을 하는 클래스를 중심으로 N:N 관계가 형성될 수 있다.
    - 여러 클래스들의 관계가 특정 이벤트들을 중심으로 복잡하게 얽힌 설계에서 유용하게 사용될 수 있다.

+ **Composite pattern**
    - 컴퓨터의 폴더 시스템 -> 포함하는 것들과 포함되는 것들이 같은 방식으로 다뤄질 수 있을 때 사용한다.

### :pushpin: 서버란 무엇인가?
* 컴퓨터다. 역할이 다른 컴퓨터다. 
* 네트워크로 연결된 다른 컴퓨터들에게 뭔가를 해주면 Server다.
* 그 서비스를 받는 컴퓨터가 클라이언트(Client)다.

### :pushpin: AWS? 클라우드 컴퓨팅이 무엇인가요?
* 회사가 자사의 시설이나 IDC에 자체적으로 서버를 두고 운용하는 방식은 On-premise 방식이다.
* 대기업에서 서버를 제공하는 것이 클라우딩 컴퓨팅 서비스다.
* 이 클라우드 역시 자사의 거대한 데이터 센터에 서로 연결된 수많은 컴퓨터들을 운용하고 있다. 다만, 사용자들에게 컴퓨터 하나를 통째로 배당하는게 아니라, 필요로 하는 만큼 떼어서 나눠준다.
* '가상 컴퓨팅'이란 기술을 사용하면, 물리적 컴퓨터 한 대에 가상의 컴퓨터 여러대를 띄울 수 있다. 컴퓨터의 물리적 자원을 필요에 따라 분할해서 사용할 수 있는 것이다.
* 세일 시즌이나 이벤트 기간에 접속량이 폭증하는 경우, 그때그때 자원이 필요한 만큼 클라우드에서 자원을 늘려주거나 줄여줄 수 있다.
* 소비자는 필요한 만큼만 사용하고 돈을 지불하면 된다. 
* 클라우드가 많을 일들을 담당해줄 수 있으므로, 자원과 비용을 줄일 수 있다.
* DB, 자료 백업, 스토리지, 자동화, 머신러닝, 블록체인까지 다양한 서비스를 이용할 수 있다.
* 클라우드에서 어디까지 해주느냐에 따라 세 단계로 나뉜다.
    - **IaaS** : (HW만 지원) 하드웨어 자원의 일부를 떼어준다. 클라우드에서는 하드웨어만 관리하고, 사용자가 직접 가상서버 하나를 운영하고 관리한다.
    - **PaaS** : (HW + 가상서버 지원) 서비스로 플랫폼이 제공된다. 가상 컴퓨터까지 클라우드에서 관리해준다. 사용자는 SW만 만들어서 올리면 된다. SW코드를 올리면, 클라우드에서 알아서 서버에 넣고 돌려준다.
    - **SaaS** : (HW + 가상서버 + SW) 다 만들어진 SW를 서비스로 제공한다.(SNS, 이메일, 유튜브 등..) 사용자들이 바로 온라인으로 사용할 수 있는 서비스.
* **아마존** AWS - EC2 / **구글** GCP - Compute Engine / **MS** Azure - Virtual Machines / **네이버** 클라우드 플랫폼 - Micro Server => 각각 1년간 IaaS 외 다수의 서비스들을 무료로 제공한다.
* 클라우드 컴퓨팅이 발달하면서 개발자들이 할 일이 적어지고, SW개발과 운영의 진입장벅이 낮아지고, 비용 부담 없이 개발에 뛰어들 수 있는 환경이 갖춰졌다.

### :pushpin: 웹 개발자들이 익스플로러를 싫어하는 이유
* 웹 표준을 지키지 않아서 익스플로러에서만 다르게 보이는 경우가 있다. HTML, CSS, JS를 다르게 읽어온다.
* 그러나 아직까지도 익스플로러의 점유율을 무시할 수 없기 때문에, 개발자들은 내가 쓴 코드가 여러 브라우저에서 잘 동작하는지 Cross Browsing을 통해 확인하는 과정을 거쳐야 한다.

### :pushpin: 정적(Static) 웹, 동적(Dynamic) 웹
* **정적 웹** : 서버에서 코드를 매번 가공해서 제공하는게 아니라, 개발자가 작성한 코드를 그대로 가져와서 보여주는 것.
* **동적 웹** : 서버가 코드를 가져올 때마다 매번 가공해서 보여주는 것.